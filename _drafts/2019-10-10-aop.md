
# Method Swizzling

所谓Method Swizzling就是使用Runtime提供的API进行方法实现的替换。

{% highlight objc %}
#import <objc/runtime.h>

@implementation UIViewController (Tracking)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        Class class = [self class];

        SEL originalSelector = @selector(viewWillAppear:);
        SEL swizzledSelector = @selector(xxx_viewWillAppear:);

        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

        // When swizzling a class method, use the following:
        // Class class = object_getClass((id)self);
        // ...
        // Method originalMethod = class_getClassMethod(class, originalSelector);
        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);

        BOOL didAddMethod =
            class_addMethod(class,
                originalSelector,
                method_getImplementation(swizzledMethod),
                method_getTypeEncoding(swizzledMethod));

        if (didAddMethod) {
            class_replaceMethod(class,
                swizzledSelector,
                method_getImplementation(originalMethod),
                method_getTypeEncoding(originalMethod));
        } else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
}

#pragma mark - Method Swizzling

- (void)xxx_viewWillAppear:(BOOL)animated {
    [self xxx_viewWillAppear:animated];
    NSLog(@"viewWillAppear: %@", self);
}

@end
{% endhighlight %}

{% highlight objc %}
static IMP
addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)
{
    IMP result = nil;

    runtimeLock.assertLocked();

    checkIsKnownClass(cls);

    assert(types);
    assert(cls->isRealized());

    method_t *m;
    if ((m = getMethodNoSuper_nolock(cls, name))) {
        // already exists
        if (!replace) {
            result = m->imp;
        } else {
            result = _method_setImplementation(cls, m, imp);
        }
    } else {
        // fixme optimize
        method_list_t *newlist;
        newlist = (method_list_t *)calloc(sizeof(*newlist), 1);
        newlist->entsizeAndFlags =
            (uint32_t)sizeof(method_t) | fixed_up_method_list;
        newlist->count = 1;
        newlist->first.name = name;
        newlist->first.types = strdupIfMutable(types);
        newlist->first.imp = imp;

        prepareMethodLists(cls, &newlist, 1, NO, NO);
        cls->data()->methods.attachLists(&newlist, 1);
        flushCaches(cls);

        result = nil;
    }

    return result;
}
BOOL
class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return NO;

    mutex_locker_t lock(runtimeLock);
    return ! addMethod(cls, name, imp, types ?: "", NO);
}


IMP
class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)
{
    if (!cls) return nil;

    mutex_locker_t lock(runtimeLock);
    return addMethod(cls, name, imp, types ?: "", YES);
}

{% endhighlight %}

上面是NSHipster中的一个例子，上面例子中没有直接调用exchange，而是先addMethod。原因在于`class_getInstanceMethod`的实现会沿着继承链，所以返回的method有可能是父类的，我们并不想交换父类的实现，所以先`class_addMethod`，这个时候就存在两种情况。

这个方法会去查看当前类是否有这个selector，如果当前类有selector的实现，则去到`method_exchangeImplementations`。

如果当前类没有这个selector，首先`class_addMethod`会为当前类的方法列表中增加这个方法，此时selector的实现就是swizzledMethod。第二步走到`class_replaceMethod`，指定swizzledSelector的实现为OriginalMethod，两次操作完成exchange。

# Aspects

Aspects的实现用到了消息转发，Aspects允许hook某个对象的方法或者类方法，步骤如下：

当hook类方法的时候，首先会替换该类的`forwardInvocation`方法实现，NSObject中的默认实现就是简单的调用`doesNotRecognizeSelector`，同时该类新建一个selector执行默认的转发实现。当hook对象方法时候，此时并不会替换类的转发方法，而是会像KVO一样，新建一个子类，对该子类进行替换转发方法，最后将对象指向新建的子类。

接下来对为当前类（hook类方法）或者新建的子类（hook对象方法）新建一个`aspect_xxx` 方法，实现就是原selector的实现；将原selector的实现替换成`_objc_msgForward`，这样当调用被hook的selector时就会强制走到消息转发阶段。

所以当hook结束后，调用selector会走到自定义的`__ASPECTS_ARE_BEING_CALLED__`转发实现中。

Aspects中将block封装成了一个MethodSignature，执行的时候通过methodSignature构建一个invocation，设置参数，最后使用block作为target去执行这个invocation。

接口中的block参数可以不设置，如果设置默认第一个是`id<AspectInfo>`，后面可以加hook方法的参数。

此时block的参数第一个是self也就是block本身，第二个是id<AspectInfo>，后面就是hook 方法的参数，这是一个可选项。判断block参数是否合法在`aspect_isCompatibleBlockSignature`中。可以看到blcok的方法签名中没有_cmd的参数，笔者猜测是因为blcok内部结构中有一个函数地址指向的就是外部的函数，执行直接是通过函数地址的方式去执行，就不需要_cmd了。

执行block的时候，根据block实际的参数个数，为创建的invocation进行设置参数，具体实现在`invokeWithInfo`。

# References

[https://nshipster.com/method-swizzling/](https://nshipster.com/method-swizzling/)

[http://www.tanhao.me/code/160723.html/](http://www.tanhao.me/code/160723.html/)

[http://zxfcumtcs.github.io/2016/01/23/iOSAOP/](http://zxfcumtcs.github.io/2016/01/23/iOSAOP/)
