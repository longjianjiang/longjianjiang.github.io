
# 面向对象开发原则

## 单一职责

类的职责明确和单一。高内聚，低耦合。

只有一个变化的因子，帮助判断是否符合单一职责。

## 开闭原则

对扩展开放，对修改封闭。

可以理解为实体增加新功能的时候可以添加代码，但是不能修改已有代码。已有代码的修改有可能出现蝴蝶效应。

## 里式代换原则

任何使用到父类类型的地方都可以使用子类类型进行替换，不会出现错误。

想象一个方法如果不遵守这个约定，那么方法内部一定需要if/else的判断。

满足这个约定可以使得继承只能对父类的功能进行扩展，而不是修改。这也是继承的作用所在。

## 依赖倒置原则

高层模块不应该依赖于底层模块，双方都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块不应该知道底层模块的实现细节。

接口应该是高层模块去指定，否则底层模块制定的接口可能暴露出实现细节，这些细节高层模块是不用关心的。

## 接口分离原则

每个接口职责单一，不同职责定义不同的接口。

## 迪米特原则

一个对象需要尽可能的少的了解其他对象。依然是为了高内聚。

## 合成原则

尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。

所谓组合的关键在于拆分，而拆分的关键是职责单一，将职责单一的各个模块进行按需组合。

# C语言中的面向对象

## 封装

[ref](https://zhengw-tech.com/2020/01/27/oop-c/)

## 继承

通过结构体的内存布局一致进行类型强转实现继承；

## 多态

可以使用函数指针来实现多态；

## 内核中的面向对象

[note1](https://lwn.net/Articles/444910/)

[note2](https://lwn.net/Articles/446317/)

# JS 原型继承

TODO

[ref](https://xta0.me/2014/06/23/JS-Design-2.html)

# 面向对象思想(封装，继承，多态)

## 继承

我判断是否使用继承的标准并不在于是否添加属性，而在于***如果采用继承之后，父类和子类之间是否保持着父类给子类提供服务的关系***。这种关系是层级关系，而不是并列关系。注意，功能拓展其实是并列关系。

面向对象导论里面提到过，继承的设计初衷其实并不在于对父类的拓展，而在于父类代码的可复用。当某一类对象都存在某个共性的时候，我们通过继承来将共性抽象出来，提高代码的可复用性。然而如今越来越多的工程师在使用继承的时候反而使用继承来给父类拓展，所以才导致了实际情况中的种种问题，所以他们的做法是不对的，也是违背继承的设计初衷的，相信他们也没系统地学习过面向对象思想。因此，业界对于这种滥用继承的情况，提倡使用组合代替继承。

但这个说法其实并不完整，如果把它说完整了就是：“使用继承来抽象多个对象的公共服务到父类，从而实现代码复用，提高可维护性；使用组合来代替继承，从而实现为对象拓展功能的需求。”

它之所以说得不那么完整的原因就在于：实际工程中，拓展功能的需求远远大于将核心代码做抽象的需求，因此只强调了后面半部分，以此来引起各位工程师足够的重视。

以上是继承，其实实际工作情况中，继承手段还被用于另一个地方，那就是多态：当子类想改变父类某个方法的实现的时候，大部分工程师往往想的是我派生一个对象出来，然后重载父类对应的方法。

# References

[http://zxfcumtcs.github.io/2018/10/04/solid/](http://zxfcumtcs.github.io/2018/10/04/solid/)
