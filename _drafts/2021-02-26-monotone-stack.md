
# 单调栈

所谓单调栈，首先是一个栈，其次就是栈内元素是升序或者降序。

当某些问题需要保持有序序列的时候，依次**入栈**，当新的元素打破了当前有序，此时需要**出栈**。出栈一般都是返回问题的结果。

看一个实际的例子，给定数组[6 4 3 2 5]，要求返回数组中每个元素下一个更大元素，没有返回-1。

最直接的方法就是两次循环，找到第一个比当前元素最大的元素。但是如何做到只遍历一次呢？一般做到时间复杂度的降低，需要使用额外的数据结构。

想一下，题目要求比当前元素大的第一个元素，那么需要是升序序列，那么其实，直接依次返回下一个元素就好。如果是倒序，那就得看后面是否存在打破倒序的元素构成局部倒序，此时就可以找到更大的元素。

所以我们创建一个栈来存储倒序的序列，当出现新的元素大于栈顶元素时，此时出栈同时记录栈顶元素的下一个大元素就是要进栈的元素。这里需要注意的一点时，因为栈中存储的事倒序的序列，所以出栈的时候是一个while循环，需要把栈中所有符合条件的元素都出栈。

拿例子来说：

```
1. 首先栈是空的，入栈，[6];
2. 入栈元素4，小于栈顶6，入栈，[6, 4];
3. 入栈元素3，2，同理，入栈，[6, 4, 3, 2];
4. 入栈元素5，此时5大于当前栈顶2，所以2出栈，[6, 4, 3]; 
	此时因为有while循环继续将栈顶小于5的元素出栈，最后将5入栈，[6, 5];
```

最后会发现栈中还留了两个元素，为了让这两个元素也可以出栈，可以往元数组中插入一个辅助数字INT_MAX，这样就可以按之前的逻辑进行处理。

小结一下，单调栈的两个点在于出栈需要循环判断，将栈中符合条件的所有元素出栈。二是插入辅助元素进行处理。

但最重要的还是深刻的理解是如何利用这样一个有序的数据结构来降低时间复杂度的。

# References

[ref](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/xiang-xi-jie-shao-dan-diao-zhan-de-li-jie-he-shi-y/)
