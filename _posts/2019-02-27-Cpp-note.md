---
layout: post
title:  "C++ 笔记"
date:   2019-02-16
excerpt:  "本文是笔者记录的一些之前不知道的C++用法"
tag:
- Cpp
comments: true
---

> 本文是笔者记录的一些之前不知道的C++用法。

# const

# decltype

`decltype` C++11 中新增的用来编译期做类型推导的一个关键字。给定一个表达式，推导出该表达式的类型。

[ref1](https://www.cnblogs.com/QG-whz/p/4952980.html)
[ref2](https://zh.cppreference.com/w/cpp/language/decltype)

# using

`using` 这个关键字其中一个功能就是指定别名，类似 `typedef`。

{% highlight cpp %}
typedef void (*fp_1) (int, int);
using fp_2 = void (*) (int, int);
{% endhighlight %}

[ref1](https://blog.csdn.net/shift_wwx/article/details/78742459)

# virtual method

```
class WCTConstraintBindingBase {
public:
    WCTConstraintBindingBase(const std::string &name,
                             WCTConstraintBindingType type);
    const std::string name;
    const WCTConstraintBindingType type;

    virtual WCDB::TableConstraint generateConstraint() const = 0;
};
```

纯虚函数，基类无法实例化，子类必须实现该函数。

# lambda

C++11 提供了匿名函数的支持，也就是所谓的 lambda表达式，定义如下:

```
[capture list](parameter list) -> return type { function body }
```

> 捕获列表指的是指匿名函数中定义的局部变量列表，一般为空。

{% highlight cpp %}
int num = 5;
cout << "num = " << num << endl;
static const auto _unused = [](int *num)
{
    *num = 7;
    return nullptr;
}(&num);

cout << "num = " << num << endl;
{% endhighlight %}

[ref1](https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html)

# template

## typename

[ref1](http://feihu.me/blog/2014/the-origin-and-usage-of-typename/)

## enable_if

[ref1](https://yixinglu.gitlab.io/enable_if.html)

# smart pointer

[ref1](https://www.cnblogs.com/jiayayao/p/6128877.html)