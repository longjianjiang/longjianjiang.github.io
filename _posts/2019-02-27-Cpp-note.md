---
layout: post
title:  "C++ 笔记"
date:   2019-02-16
excerpt:  "本文是笔者记录的一些之前不知道的C++用法"
tag:
- Cpp
comments: true
---

> 本文是笔者记录的一些之前不知道的C++用法。

# macro

# # 

`#` 用来将给定的参数字符串化，如下例子:

{% highlight cpp %}
#define My_STRINGIFY(str) #str

std::cout << My_STRINGIFY(nancy) << std::endl;
{% endhighlight %}

# constexpr

编译时运算。发生在编译期的运算，提高运行时效率；编译期检查保证安全；简化并发；

# const

# decltype

`decltype` C++11 中新增的用来编译期做类型推导的一个关键字。给定一个表达式，推导出该表达式的类型。

[ref1](https://www.cnblogs.com/QG-whz/p/4952980.html)

[ref2](https://zh.cppreference.com/w/cpp/language/decltype)

# using

`using` 这个关键字其中一个功能就是指定别名，类似 `typedef`。

{% highlight cpp %}
typedef void (*fp_1) (int, int);
using fp_2 = void (*) (int, int);
{% endhighlight %}

[ref1](https://blog.csdn.net/shift_wwx/article/details/78742459)

# virtual method

{% highlight cpp %}
class WCTConstraintBindingBase {
public:
    WCTConstraintBindingBase(const std::string &name,
                             WCTConstraintBindingType type);
    const std::string name;
    const WCTConstraintBindingType type;

    virtual WCDB::TableConstraint generateConstraint() const = 0;
};
{% endhighlight %}

纯虚函数，基类无法实例化，子类必须实现该函数。

# lambda

C++11 提供了匿名函数的支持，也就是所谓的 lambda表达式，定义如下:

```
[capture list](parameter list) -> return type { function body }
```

> 捕获列表指的是指匿名函数中定义的局部变量列表，一般为空。

{% highlight cpp %}
int num = 5;
cout << "num = " << num << endl;
static const auto _unused = [](int *num)
{
    *num = 7;
    return nullptr;
}(&num);

cout << "num = " << num << endl;
{% endhighlight %}

[ref1](https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html)

# template

## SFINAE

替换失败不是错误 (Substitution Failure Is Not An Error)，是C++模版重载决议的一个原则，看下面的一个例子:

{% highlight cpp %}
struct Test {
    typedef int foo;
};

template <typename T> 
void f(typename T::foo) {} // Definition #1

template <typename T> 
void f(T) {}               // Definition #2

int main() {
    f<Test>(10); // Call #1.
    f<int>(10);  // Call #2. Without error (even though there is no int::foo) thanks to SFINAE.
}
{% endhighlight %}

也就是说在模版决议中，只要有一个可以正确推导，那么其他可能产生编译错误的并不会引发错误，也就是所谓的 `SFINAE`。

## typename

`typename` 和 `class` 都可以用来指定模版的参数类型，考虑下面一种情况:

{% highlight cpp %}
template <class T>
void foo() {
    T::iterator * iter;
}
{% endhighlight %}

我们肯定不假思索的以为`T::iterator`是一个类型，但是因为模版参数T直到模版实例化后才会确定类型，所以上述 `T::iterator` 并不一定是一个类型，它有下面三种情况:

- 静态数据成员
- 静态成员函数
- 嵌套类型

{% highlight cpp %}
struct MyStruct {
    static int A;
    static int B();
    typedef int C;
}
{% endhighlight %}

所以为了消除这种不一致的可能性，`typename` 可以用来告诉编译器 `T::iterator` 就是一个类型，否则编译器不会将其当作一个类型，从而消除了不一致的情况。

{% highlight cpp %}
template <class T>
void foo() {
    typename T::iterator * iter;
}
{% endhighlight %}

[ref1](http://feihu.me/blog/2014/the-origin-and-usage-of-typename/)

## enable_if

{% highlight cpp %}
template <typename T>
typename std::enable_if<std::is_integral<T>::value, bool>::type
is_odd(T data) {
    return bool(data % 2);
}
{% endhighlight %}

先看一个例子，定义了一个模版函数，判断整数是否为奇数，所以需要限制 data 必须是整数类型，所以使用到了 `enable_if` 来校验模版参数的类型。

{% highlight cpp %}
template <bool Cond, class T = void> struct enable_if;

std::enable_if<std::is_integral<T>::value, bool>::type
{% endhighlight %}

当 `Cond` 为true的时候，类型 `T` 才会被定义。上述例子中当T是整数类型时，根据`enable_if`定义的bool类型作为函数返回值，否则会编译失败，因为类型未定义。下面看下实现:

{% highlight cpp %}
template <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};
{% endhighlight %}

第一个模版为普通模版定义，第二个模版为偏特化版本的模版定义，所以当 `Cond` 为false时会到第一个模版，为true时会到第二个模版，可以看到第二个模版结构体中使用 typedef 定义了 type。

[ref1](https://yixinglu.gitlab.io/enable_if.html)

[ref2](https://www.jianshu.com/p/4be97bf7a3b9)

# smart pointer

`shared_ptr` 使用引用计数来管理内存，当引用计数为0时，回收对应的堆内存，和Apple的ARC类似。

> 当出现循环引用的时候，需要使用 `weak_ptr`。

{% highlight cpp %}
shared_ptr<Person> p1(new Person(1));

shared_ptr<Person> p2 = make_shared<Person>(2);

// 首先生成一个新的对象指针，将p1指向对象的引用计数减1，此时引用计数为0，则销毁p1指向对象，最后将新生成的对象指针交给智能指针。
p1.reset(new Person(3));
{% endhighlight %}

[ref1](https://www.cnblogs.com/jiayayao/p/6128877.html)

# default & delete

先看一个例子:

{% highlight cpp %}
class Person {
public:
    Person() = default;

    Person( const Person & ) = delete;
    Person &operator=( const Person & ) = delete;
};
{% endhighlight %}

上面我们定义了一个Person类，我们使用 `=default` 标示了默认的无参数的构造函数让编译器自动生成，使用`=delete`标示了拷贝构造函数和拷贝赋值运算符重载不允许被使用。

`=default` 仅适用于类的特殊成员函数(默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符），且该特殊成员函数没有默认参数。

`=delete` 必须在函数第一次声明的时候将其声明为 deleted 函数，否则编译器会报错。

[ref1](https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html)

# overload operator

- 类型强制转换运算符重载

看一个例子:

{% highlight cpp %}
class Column {
public:
    operator std::list<int>() const;
};

Column::operator std::list<int>() const {
    return {5, 7};
}

int main(int argc, const char * argv[]) {
    Column col;
    std::list<int> list = (std::list<int>)(col);

    for (auto num : list) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    return 0;
}
{% endhighlight %}

我们为`Column`类添加了一个强制转换为 list的重载，返回一个默认的list。

# iterator_traits

# 左值 & 右值

