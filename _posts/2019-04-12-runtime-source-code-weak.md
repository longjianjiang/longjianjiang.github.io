---
layout: post
title:  "【Runtime源码】weak"
date:   2019-04-12
excerpt:  "本文是笔者阅读Runtime源码关于弱引用实现的笔记"
tag:
- Runtime
comments: true
---

> 本文笔者根据 Runtime 750 源码分析弱引用的实现。

之前笔者在[内存管理](http://www.longjianjiang.com/memory-management/)中提到了OC中使用`__weak`修饰符来打破循环引用，使用该修饰不会影响对象的引用计数，也就是赋值给弱引用的时候不会去调用`retain`方法。

## 开始

这里笔者先提出几个疑问：

1.这里的弱引用不持有是什么意思？
2.所谓强引用持有又是什么意思？
~~3.一个类里面的成员不都应该是属于该类吗？也就是持有所有成员。~~

其实不知道大家有没有发现，之前手动引用计数时期，并没有weak的概念，为什么呢？因为那个时候需要我们自己去写引用计数的方法，所有的一切都交给程序员去控制。而自动引用计数到来之时，之前的那些控制引用计数的方法，由编译器在合适的地方进行插入。那编译器是如何知道在哪里进行插入呢？所以此时有了所谓强引用的概念，默认对象都是强引用。

{% highlight objc %}
id obj = [NSObject new];
id sobj = obj;
id __weak wobj = obj;
{% endhighlight %}

当将一个对象赋值给另一个对象的时候，编译器发现`sobj`是强引用，此时会调用`objc_retain`将`obj`的引用计数加1。编译器发现`wobj`是一个弱引用，此时并不会调用`objc_retain`将`obj`的引用计数加1。

所以所谓强引用和弱引用的区别就在于是否影响对象的引用计数，他们都是指向同一块堆内存，因为使用引用计数的内存管理方式，防止循环引用而出现的一个解决方案而已。

所以所谓的持有其实可以理解为是否引用对象的引用计数。类中成员是否用`__strong`,`__weak`修饰还是一样的道理，当另一个对象`o`用来赋值给类中成员时，如果是强引用则会影响`o`的引用计数，弱引用则不会。这也就是View的delegate属性都设置为`__weak`的原因，如果设置为`__strong`，控制器持有View，而View的delegate会用控制器来赋值，所以View就影响了控制器的引用计数，从而导致了控制器不能释放。

下面来看runtime中如何来记录弱引用关系的，以及如何实现当对象销毁时，对应的弱引用被置为`nil`的。

## 




