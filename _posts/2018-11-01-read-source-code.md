---
layout: post
title:  "关于源代码"
date:   2018-11-01
excerpt:  "本文是笔者阅读源代码的一些思考"
tag:
- Thought
comments: true
---

> 本文是笔者最近在阅读MMKV源代码的一些思考；

在阅读MMKV源代码中，读到计算一个方法用于计算int型value实际占的位数，代码如下：

{% highlight objective_c %}
int32_t pbRawVarint32Size(int32_t value) {
	if ((value & (0xffffffff << 7)) == 0)
		return 1;
	if ((value & (0xffffffff << 14)) == 0)
		return 2;
	if ((value & (0xffffffff << 21)) == 0)
		return 3;
	if ((value & (0xffffffff << 28)) == 0)
		return 4;
	return 5;
}
{% endhighlight %}

第一次看这个方法其实我能理解第一次为什么是左移动7位，因为最高位是符号位。但是再在当value占16位的时候，为什么左移14位，而不是15位呢，符号位只有一位啊。

随后我看到一篇介绍Protocol Buffer的文章，里面说到了其编码方式，用到了一种叫做`Varint`表示数字的方法。

- 使用最少的字节来保存一个数字，比如一个`int32_t`的value存1，原本需要4个字节，而实际这个数字只占用了一个字节，所以使用该种方式只需要占用一个字节就可以保存改数字了。

- 这种方式的每个字节的第一位有特殊含义，如果该位为1说明后续的字节是该数字的一部分；如果该位为0，说明此时的字节就是该数字的最后一个字节。

> 而且Protocol Buffer使用了小端的方式来存储，也就是第一个字节存储了数字的最低位。 大端则第一个字节存储了最高位。

有了以上的知识，上面的那个方法其实也就很明白了，因为使用了`Varint`的方式了来表示数字，每个字节的第一位有特殊含义，所以一个字节只有7位可用，2个字节也就是14位，依次类推，十分明了。

上面的一个例子说明，我们在阅读源代码时，肯定会遇到很多疑问，其实很多疑问我们当时觉得不可思议，一头雾水，其实当你回过头来看的时候，一切是那么的自然，这也就是一种成长吧。

所以这说明阅读源代码对自身的提升是有很大帮助的，不仅仅可以提高原有知识的质量，而且可以拓宽知识面。

以上就是笔者的一点小体会，记录下来。
