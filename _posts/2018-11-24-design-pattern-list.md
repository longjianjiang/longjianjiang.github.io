---
layout: post
title:  "设计模式学习笔记"
date:   2018-11-24
excerpt:  "本文是笔者学习设计模式的笔记"
tag:
- Architecture
comments: true
---

# UML

UML笔者大学学过，这里结合自己的理解记录下来其中的一些东西。

## 类图中的各种关系

> 纵向上的关联；

- 继承

继承关系可以通过 `... is a ...` 来进行判断。

泛化关系：类的继承，接口的继承都属于泛化，也就是继承语义。
实现关系：抽象到一般的关系，比如动物和狗的这种关系。

> 横向上的关联；

- 依赖关系

`... uses ...`

表示一个对象运行时可能会使用到另一个对象，是一种临时性的关系，运行时可能发生变化，耦合较弱。

依赖是有方向的，所以存在双向依赖的情况。

实际代码中的表现为类方法的入参，此时类并不持有入参。

- 关联关系

`... has ...`

类似依赖关系，但是依赖的强度更大。

实际代码中的表现为类成员变量。

- 聚合关系

`... owns ...`

表示一种从属的关系，比如学生属于某个班级，学生班级算一种聚合关系，但是两者之间互相独立，班级不存在了学生依然存在。

- 组合关系

`... is part of ...`

表示一种整体部分的关系，密不可分，比如人和心脏的关系。

---

# Design Pattern

## 对象创建

### 原型模式

一种创建对象的模式，当某个对象结构比较复杂，比如递归结构，如果外界需要一个新的此种结构的对象，这个时候手动去创建就会很不方便，所以需要一种印章的方式去生成一个这样的对象出来，这个生成的方法一般就是所谓的复制，而这个被复制的对象就是所谓的原型。

这样好处在于，使用者直接调用一个copy方法就可以获取到想要的新的对象，至于创建的过程就被隐藏了，使得这块的逻辑固定在一个地方，方便维护和修改。

### 工厂方法

所谓工厂方法的目的在于消除了代码中对具体类的耦合，使用其父类的抽象接口，方便扩展。此时需要获取对应子类的实例，一种方式是抽象类提供若干类方法去创建实际的子类对象，比如NSNumber的很多类方法。

第二种方式，需要额外创建一个所谓的`xxxGenerator`接口，每个具体的类去实现这个接口，返回自身的实例，这样外界可以选择自己需要的generator。

[ref](https://blog.csdn.net/Longtermevolution/article/details/107734026)
### 抽象工厂

抽象工厂可以看作是工厂方法的一种推广，当某个工厂需要生产一类产品的时候，这个时候就需要使用抽象工厂，此时抽象工厂生产的是某个工厂，这个工厂则有具体的工厂方法去创建具体的对象，而这些工厂的工厂方法则是抽象工厂中所定义的。

举个例子，有个抽象工厂是生产各种品牌的汽车，类型有轿车，越野车两种。此时可以定义两个不同品牌的工厂，这两个工厂则去具体实现去制造轿车和越野车这两个工厂方法。

NSNumber的实现也是一种抽象工厂，首先NSNumber内部定义了若干公共的方法，就是工厂的工厂方法。NSNumber的若干类方法返回的其实就是一个实际的工厂，这些工厂都实现了工厂方法。这种方式也是所谓的类簇模式，隐藏类具体子类的实现这些工厂方法的细节。

[ref](https://www.cnblogs.com/qiaoconglovelife/p/5750290.html)

### 单例模式 

单例模式在iOS中也很常见了，苹果很多地方都用到了单例模式，比如`sharedObject`，`defaultObject`等。     

单例模式其实很好理解，有时候为了全局的控制某个类只允许有一个实例，此时我们就可以用单例模式去进行限制。

> 有时候某个类默认提供一个全局的实例，但是同时允许我们创建自己的实例，比如`FileManager`类，一般我们在后台线程会自己创建一个`FileManager`类的实例。

有时候，我们想要的其实不一定是类一定有一个唯一的对象，而是保证类对象有一个唯一的状态。这个时候可以使用[MonoState](https://www.jianshu.com/p/9840f04669f4)。

[单例的思考](https://www.cnblogs.com/weidagang2046/archive/2009/10/31/1593473.html#!comments)

### 生成器模式

生成器模式是构建对象的一种设计模式，一般当某个对象较为复杂属性比较多，而且这些属性可能会有较大的变化，这些变化可能是有一些特定的逻辑。

所谓builder就是将创建这个对象，同时负责操作这些属性，处理相关逻辑，这样就可以将这部分逻辑独立出来，粒度更加小，也就更容易复用。

通过builder可以隔离mutable，通过builder返回不可变的对象，保证了安全性。

[ref1](https://blog.csdn.net/justloveyou_/article/details/78298420)
[ref2](https://www.swiftbysundell.com/articles/using-the-builder-pattern-in-swift/)

## 接口适配

### 外观模式 

外观模式用来组合一个或多个的系统的接口，对外提供一个简洁的单一使用接口，这样外界可以不去关心内部的实现细节，更方便的去使用；

外观模式，目的在于新建一个facade层，这个层对外提供某个系统下的若干功能，这样外界使用直接调用这个facade提供的方法即可，不需要知道系统内部的结构。

在做组件化的时候，构造出一个控制器的时候，此时可能需要给控制器传一些必要的参数，而且可能参数不止一个，此时可以定一个统一的接口`setParams:`的方法，用字典的形式进行包装参数，这样调用方来说facade就是这个方法，每个具体的控制器自己内部根据传入的字典进行处理即可。

### 桥接

所谓桥接模式，将抽象的接口和实现的接口独立开来，进行组合使用。抽象接口由外界使用，实现接口定义了抽象接口所需的实现逻辑。

这个时候，抽象接口的实现可以添加若干个独立的操作，这些操作的实现都由实现接口的具体实现类去实现，这样双方都可以进行独立的变化。

这也是组合模式的一个使用例子。

### 适配器模式 

所谓适配器模式就是一个中间人，实现一个目标接口同时内部使用到了对使用者不可见的其他接口对象，对使用者来说屏蔽了一些细节。另一个好处就在于当其他不可见的接口对象有改变的时候，此时对使用者来说是透明的，他不必关心这些改变。
 
适配器模式，和现实中使用的电源适配器很像。JDBC使用的其实就是适配器模式，JDBC定义了一系列的通用接口，各个数据库实现这个接口，我们在使用的时候就可以不关心是哪种数据库，用提供的接口就好，实现部分都在各个数据库提供的jar包中。

网络请求中可以使用这种模式来进行数据的转化，相当于新添加一层用户逻辑转化，这样转化逻辑可以被复用，控制器也减负了。

[ref](https://medium.com/swiftcraft/swift-solutions-adapter-pattern-a2118a6a2910)

## 对象去耦

### Mediator Pattern

组件化中用到了中介者模式，之前工程中各个模块相互依赖，随着工程规模的扩大，导致各个模块很难独立出来。这个时候需要一个中间层，也就是所谓的Mediator，各个模块只依赖Mediator，这样子各个模块就独立出来了。

此时Mediator提供调用其他模块的接口，需要依赖其他模块现在只需要依赖Mediator即可，而且Mediator自身并不依赖任何模块。

Mediator使用runtime进行调度。

### Observer Pattern

监听者模式，iOS中的KVO就是一种监听者模式，或者使用Rx的第三方框架也可以实现监听者模式。    

## 抽象集合

### 组合模式

所谓组合模式，就是让树形结构中的每个节点有统一的接口，这样整个大的结构也可以作为一个单一的抽象结构去使用，比如UIView的设计就是一种组合结构。

### 迭代器模式

迭代器模式笔者是在算法中接触到的，STL中使用了大量的迭代器的接口，这样做的好处在于抽象了具体的数据结构，让某一个算法可以适用于不同的数据结构。

OC里面的集合遍历提供的方法也是一种迭代器模式，其中一种block API的遍历叫做内部迭代器，此时迭代器不会暴露给外界，外界只需要提供一个处理的blcok，内部使用迭代器取到每个元素去执行block。

## 行为扩展

### 访问者模式

所谓访问者模式，在不改变原类的结构下，添加一个访问者的接口，访问者根据原类对象去做一个新的操作，来达到扩展原对象的功能。

[ref](https://medium.com/@lazarevzubov/visitor-design-pattern-in-ios-and-swift-universe-e7a953341a6f)
[ref](https://www.jianshu.com/p/cd17bae4e949)

### 装饰模式

装饰对象中持有原有对象，对原对象操作之前添加若干操作，来进行扩展原对象的行为。
比如给UIImage增加图片处理的装饰器。

{% highlight swift}
public final class Kingfisher<Base> {
    public let base: Base
    public init(_ base: Base) {
        self.base = base
    }
}
public protocol KingfisherCompatible {
    associatedtype CompatibleType
    var kf: CompatibleType { get }
}

public extension KingfisherCompatible {
    public var kf: Kingfisher<Self> {
        get { return Kingfisher(self) }
    }
}
extension ImageView: KingfisherCompatible { }
{% endhighlight %}

上面的Kingfisher其实就是一种装饰者模式。

[ref](https://medium.com/swiftcraft/swift-solutions-decorator-pattern-49fcfb18c1ce)

### 责任链模式

对象中持有同一类型的其他对象，形成一条链条，定义一个操作，链条上的对象都有机会去进行处理。
`nextResponder`就是责任链模式；

## 算法封装

### 模版方法

将某个特定算法定义好步骤，让其中可变的部分交给子类去实现，来达到共同的算法部分可以在父类中进行复用。

### Strategy Pattern

当需要使用很多if/else的逻辑的时候，可以考虑将每个case下的处理逻辑封装成一个策略，此时需要定义一个通用的接口来表示这些策略需要做的事情，然后将每个case下的逻辑放到具体的策略类中。
这个时候某个对象持有策略类，使用策略的接口去处理某些逻辑，来达到扩展对象功能的目的；这和装饰模式有点像，不过区别在于策略是在内部进行扩展。
这样的好处在于，首先不需要写很多if/else，即使以后多了某种情况，也不需要添加新的if/else；第二点在于可以更好的复用这些逻辑；

当代码里出现很多if/else的时候，这个时候其实就需要进行一定封装改造了。并不是说if/else有问题，而且if/else下的逻辑需要独立出来。这样一方面可以更好的复用，另一方面也让各个部分职责更加单一。

### 命令模式

将某个操作封装成一个对象，这样这个操作就可以以参数的形式进行传递。此时可以将对象进行存储，所以可以更好的支持撤销操作。
NSInvocation就是一种命令的封装。

---

Q: 在网速不可连接时全部的view（无论是tableView，webview，或是其它自定的view）要统一显示一个提示页面，上面有重点重新连接的button;
A: command模式。这些view都应该写一个switchToType的方法。网络失败的话就由controller调用view的这个方法去切换view的展示。

## 性能与对象访问

### 享元模式(flyweight)

当需要创建大量的对象的时候，并且这些对象有固定的信息是可以保持不变进行共享的，此时可以将状态进行划分，一部分可变的，一部分不可变的，这样创建的时候，这部分不可变的就可以不用重复创建。

### 代理模式 

代理模式和名称一样，提供一个代理对象来控制对原对象的访问。代理对象持有原对象，当收到外界请求的时候，将请求转发给原对象。
NSProxy 就是一种代理。

## 对象状态

### Memento Pattern

备忘录模式，笔者之前没有接触过这种模式。主要目的是存储类的某个状态同时提供一个方法使得该类未来可以恢复到该状态。    
  
不过这种目的，其实类似于为了不使某个类变得很大很复杂，将一部分功能转移出来类似，这里的功能就是提供一种状态恢复的功能。        

# References

[https://www.cnblogs.com/weidagang2046/archive/2009/12/10/1620587.html](https://www.cnblogs.com/weidagang2046/archive/2009/12/10/1620587.html)

[https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html](https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html)

[https://www.oodesign.com/](https://www.oodesign.com/)

[https://medium.com/swiftcraft](https://medium.com/swiftcraft)
