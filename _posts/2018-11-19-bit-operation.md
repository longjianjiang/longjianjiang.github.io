---
layout: post
title:  "二进制位操作"
date:   2018-11-19
excerpt:  "本文是笔者关于位操作的笔记"
tag:
- Algorithm
comments: true
---

笔者先以Leetcode上的一道题开始，要求计算两个int型数字之和，不允许使用`+` 和 `-`操作符。         
其实题目中既然已经说了不允许使用`+` 和 `-`操作符，而且又让我们去求和，其实我们很自然的想到可以使用位运算符去计算。因为这些数字本身就是以二进制的形式存储在计算机中的。        

加法其实可以分为两个子操作，一个为求和一个是进位。
> 假设计算 a + b, 一个特殊的情况当 b 为0时，此时和就是 a;

所以我们每次可以分别计算 a 与 b 的进位与和，直到进位为0，此时我们也就得出了和。

```
int getSum(int a, int b) {
    while (b) {
        int left = (a & b) << 1; 
        a = a ^ b;
        b = left;
    }
    return a;
}
```
> (a & b) << 1 找到需要进位的位将其进位，也就是左移一位，也就是往高位加1； 其实我们进行十进制计算也是这样的，当个位需要进位时，会将十位加1。

比如现在需要计算 3 + 1, 也就是0011 + 0001。

```
1. a = 0010, b = 0001 << 1 = 0010 // 2 + 2
2. a = 0000, b = 0010 << 1 = 0100 // 0 + 4
3. a = 0100, b = 0000 << a = 0000 // 4 + 0
此时 b == 0 ,所以 和为 a 也就是 0100。
```

通过上面的步骤我们可以看出，通过位运算符，我们将两个数相加的过程每次替换成了另外两个数字的想加，也就是进位与和，他们与原先数字是等价的，变换最后就是当进位为0说明此时计算结束。

## 操作符

```
&   : 当左操作数的值和右操作数的值同时为1时，结果为1，否则结果为0
|   : 当左操作数的值和右操作数的值同时为0时，结果为0，否则结果为1
^   : 当左操作数的值和右操作数的值相同时，结果为0；不相同时，结果为1
~   : 将操作数二进制中1变为0，0变为1
<<  : 将左操作数的值往左边移动右操作数指定的位数，也就是左操作数最左边的右操作数指定的位数被丢弃，右边空出来的位补0
>>  : 将左操作数的值往右边移动右操作数指定的位数，也就是左操作数最右边的右操作数指定的位数被丢弃，左边空出来的位补0或者左操作数的符号位，第一种叫做逻辑右移，第二种叫算数右移
```

> 以上就是所有的和位运算相关的操作符。      

## 补码

> 我们之前说的二进制形式，其实是以补码的形式存储在计算机中的。与补码对应的还有原码和反码。 

比如说现在有`int a = -3;` a 变量存储了负数3。

> 下面以8位二进制来说明；

- 原码

原码就是二进制最高位用来表示符号位，0代表正数，1代表负数，后面位用来表示数字本身。       
负数3的原码就表示`1000 0011`。

- 反码

当数字为负数时，反码就是将原码的数值部分每一位取反。否则和原码一样。        
负数3的反码就表示为`1111 1100`。

- 补码

当数字为负数时，补码就是将原码的数值部分每一位取反后加1。否则和原码一样。        
负数3的补码就表示为`1111 1101`。


## 常用操作

- x & 1; 

判断奇偶数，等同于 `x % 2 == 1`, 当1说明是奇数，0为偶数。

- x & (x - 1);

将x最低位的1置为0。

- x &= -x;

得到x最低位的1，Leetcode 260有使用到。其实就是用到了补码，取反加1，这个1肯定就是在最低位，这样&时就只保留了最低位的1。


## 最后

位运算的应用还是很多的，除了一些算法题，比如最近笔者看的MMKV中用来进行编码解码Protocol Buffer时就用到了很多位运算符。所以笔者以为，首先我们得熟悉这些运算符，然后实际过程中当出现二进制形式的时候，我们可以考虑是否可以用位运算符进行解决，多练自然就熟悉了。