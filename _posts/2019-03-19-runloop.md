---
layout: post
title:  "Runloop笔记"
date:   2019-03-19
excerpt:  "本文是笔者学习Runloop的笔记"
tag:
- OS
comments: true
---

> 之前笔者在学习多线程时，涉及到了runloop的知识，笔者将更加详细的总结记录下来。

所谓runloop其实和线程的关系很密切，我们知道默认线程只是简单的执行一段任务，执行结束后，线程也就结束了。但是为了不频繁的创建线程，所以加了一个事件循环的功能，让线程可以不断的处于工作状态。在iOS/Mac 开发中这种事件循环被叫做runloop（在 Cocoa 和 Core Foundation 有两个对应的类：NSRunLoop 和 CFRunLoop）。下面给出一个示意图:

> CFRunLoop是线程安全的，而NSRunLoop是非线程安全的；

![runloop_1]({{site.url}}/assets/images/blog/runloop.jpg)

## Source

上图可以看到runloop接收的事件来源有两种，Input sources 发送来自其他线程或者其他应用的异步事件，Timer sources 则可以定时发送或者重复发送同步事件。Input sources 来源于线程外部，而Timer sources来源于线程内部。

Input sources 有两种实现，一种基于端口(Mach端口)称作Source1，另一种则是自定义称作Source0。两种方式的区别在于，基于端口的事件是由内核发送的，可以主动唤醒runloop，而自定义的事件则需要通过先将事件标记为待处理，然后手动唤醒runloop去处理该事件。

Timer sources 会在预定的时间点向runloop发送同步事件，当到了指定的时间，runloop被唤醒去执行该事件，但是此时不一定就执行该事件，可能当前runloop正在处理其他的事件，只能等待下一次runloop执行，所以预先设置的事件点真正执行的时候是可能存在误差的。

Cocoa Perform Selector sources 是cocoa中定义的一种在任意线程执行selector的 sources。当selector执行完成后，该source会被移除。其实这种sources还是通过上面两种sources来实现的。在某个线程执行selector的前提是，该线程有一个活跃的runloop，同时runloop每次循环会将处理队列中selector一并执行，并不是循环一次处理一个selector。

`performSelector:withObject:afterDelay:` 方法使用的是Timer sources。`performSelectorOnMainThread:withObject:waitUntilDone:` 方法使用的则是Source1，通过系统的Mach端口，因为NSRunLoop是非线程安全的，所以在不同线程间操作Timer是未定义的。

## Observer

runloop允许我们设置观察者，来监听runloop的执行状态，有下面几个触发事件点:

{% highlight objective_c %}
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL << 0),
    kCFRunLoopBeforeTimers = (1UL << 1),
    kCFRunLoopBeforeSources = (1UL << 2),
    kCFRunLoopBeforeWaiting = (1UL << 5),
    kCFRunLoopAfterWaiting = (1UL << 6),
    kCFRunLoopExit = (1UL << 7),
};
{% endhighlight %}

## Mode

前面提到的Source和Observer都被称为 mode item，而这些 mode item 是需要添加到mode中。所谓mode其实就是Sources 和 Observers的集合，而runloop每次运行只能运行在指定的mode中。正是因为有了不同的mode，runloop就可以在执行中过滤到不相关的事件源，在特定场合提高执行效率。所以当一个事件发送时runloop不是处于该事件所属的mode时，此时该事件会被存放起来，一直等到runloop运行到所属的mode。

下面给出runloop预定义的一些mode:

```
NSDefaultRunLoopMode : 默认大多数情况都处于这个默认的mode；
NSEventTrackingRunLoopMode : 当ScrollView滚动时处于这个mode；
NSRunLoopCommonModes : 这个mode其实是其他mode的集合，上述默认mode和滚动mode就包含在这个mode中；
```

## 运行过程

{% highlight objective_c %}
struct __CFRunLoopMode {
    CFStringRef _name;
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
};
struct __CFRunLoop {
    CFMutableSetRef _commonModes;
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;
    CFMutableSetRef _modes;
};
{% endhighlight %}


## References

[https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1)

[https://www.mikeash.com/pyblog/friday-qa-2010-01-01-nsrunloop-internals.html](https://www.mikeash.com/pyblog/friday-qa-2010-01-01-nsrunloop-internals.html)