---
layout: post
title:  "操作系统内存管理学习笔记"
date:   2019-03-22
excerpt:  "本文是笔者学习操作系统内存管理的笔记"
tag:
- OS
comments: true
---

> 本文笔者总结操作系统层面是如何进行内存管理的，不涉及具体的实现算法，只介绍基本原理。

内存是计算机中最重要的资源之一，而且内存的容量是有限的，同时计算机中的应用程序的数量很大，所以为了高效的利用内存，操作系统必须以一定的方式对内存进行管理。

## 存储结构

计算机存储是有一个层次的，如下图所示:

![os_memory_management_1]({{site.url}}/assets/images/blog/os_memory_management_1.png)

越往上存储容量越小，读写速度越快，价格越高。

所以内存管理的目的就是协调和利用好这些不同的存储空间，以提高系统的执行效率。

## 进程介绍

这里简单介绍下进程相关概念，具体可以参考[这里](http://www.longjianjiang.com/process/)。

进程是操作系统中占有资源的最小单位，进程由程序，数据，进程控制块(PCB)三部分组成。所谓PCB就是用来记录进程的一些关键信息，比如进程标识符，程序和数据的内存地址等信息，这样操作系统就可以直接访问PCB去获取这些信息从而调度进程。

当计算机中的一个应用程序运行，首先需要将程序和数据装入内存，从而产生一个进程。

## 内存抽象

因为操作系统同一时间可能运行多个进程，所以不能直接操作内存地址，因为如果多个进程操作同一个内存地址可能导致错误。为此引入了地址空间的概念，这就允许每个进程有属于自己的地址。这需要CPU中有两个寄存器，一个是基址寄存器用来保存进程的起始地址，界址寄存器用来保存上限，防止内存溢出。

所以此时进程中访问内存地址是通过基址加上偏移量计算出实际的物理地址，因为每个进程的地址是不同的，所以此时也就不会出现多个进程操作同一块内存的可能，避免了错误的发生。

因为计算机中的应用程序很多，如果同时运行，内存大小就会存在不足，**交换技术**就是解决这个问题的。交换的原则其实很简单，将闲置的进程交换出内存，暂存到磁盘中，等到需要执行的时候再交换回内存。

> 下面就是如何给应用程序分配内存的几种不同的方式。

## 连续存储

所谓连续存储就是为应用程序分配一段连续的内存空间，这很好理解。连续存储有两种不同的实现方式:

### 单一连续存储

这种方式最简单，不过只适用于单用户单任务的操作系统。此时内存分为系统区和用户区，系统区只能供操作系统使用，余下的内存空间就是用户区，有时也会额外留出一部分给驱动程序使用。

### 分区存储

为了支持多道程序系统，引入了分区存储。所谓多道程序系统就是内存中可以存放多个应用程序，他们都处于运行中，这样可以提高CPU的使用率。

分区存储即是将内存划分为若干的相等或者不相等的分区，操作系统会占用其中一个分区，剩下的分区给应用程序使用，每个应用程序可能会占用一个或多个分区。

#### 固定分区

所谓固定分区即将内存划分为若干个固定大小的区域。

这些分区可以大小相等，此时适合多个相同的应用程序并发执行；分区大小也可以不想等，此时有多种不同大小的size，根据应用程序的大小分配合适的分区即可。

此时一般会维护一张分区使用表，记录了各个分区的起始地址，分区大小，以及是否分配状态。当应用程序要加载进内存时，内存分配程序会查该表找到一个合适的分区，用于分配给应用程序，同时更新分配状态，如果没有找到合适的分区则拒绝分配内存。

![os_memory_management_2]({{site.url}}/assets/images/blog/os_memory_management_2.png)

固定分区的优点是实现简单，缺点在于可能产生内碎片，因为分区的大小是固定的，导致可能应用程序只占用了分区的一部分内存，从而导致了内存的浪费；同时分区总数是固定的，从而限制了并发执行的数目。

#### 动态分区

所谓动态分区就是根据应用程序要求的内存创建分区，同时允许在执行过程中动态调整分区大小。

动态分区分配其实就是从内存中寻找一个空闲分区，该分区大小需要大于等于应用程序大小，如果大于应用程序大小，此时该分区会被分割为两部分，一部分就是应用程序大小的分区将其标记为占用，剩下的则被标记为空闲。分区释放的时候需要将相邻的空闲分区合并成一个大的空闲分区。

下面给出几种常见的分区分配算法:

> 动态分区可以使用双向链表来存储各个分区，链表中的节点存储了分区的信息。

- 首次适配法(first fit)

从链表头节点开始查找，找到第一个符合要求的分区后进行分配，若没有找到则分配失败。

该算法的优点每次从低地址寻找，可以将较大的空闲分区保留在高地址。缺点在于低地址部分随着不断的划分，会产生很多难以利用的小分区，又因为每次从低地址开始查找，额外增加了查找时间。

- 下次适配法(next fit)

该算法需要一个额外的指针标记上次分配的空闲分区的下一个空闲分区，查找时从这个指针位置开始查找，如果到尾部还没有找到则去头部进行继续查找，直到找到一个符合要求的分区将其分配，找到后更新指针。

该算法的优点在于使空闲分区分布的更加均匀，缺点在于不容易保留大的空闲分区。

- 最佳适配法(best fit)

该算法会在所有空闲分区按容量从小到大的顺序形成的一个空闲链表中中找到一个最小的满足条件的分区将其分配。

该算法的优点在于可以保留住大的空闲分区，并且从单个应用程序的角度来看，外碎片较小，缺点在于从因为最佳的缘故每次剩余的空闲分区是很小的，所以从整体来看形成来较多的外碎片。

- 最坏适配法(worst fit)

该算法会在所有空闲分区按容量从大到小的顺序形成的一个空闲链表中寻找，只要第一个满足要求将其分配即可。

该算法的优点在于不容易形成外碎片，因为留下的空闲分区不会太小，缺点在于难以保留大的空闲分区。

```
最坏适配法和之前所说的三种算法一起，也被称为顺序搜索法。
```

- 快速适配法(quick fit)

也被称为分类适配法，将空闲分区按大小进行分类，建立若干个空闲分区链表。所以寻找空闲分区只需要去合适大小的空闲分区链表中取第一个分配即可。

该算法的优点在于进行空闲分区分配时，不会产生分割，所以可以保留大的空闲分区，缺点在于实现复杂，系统开销比较大。

总的来说动态分区的优点在于没有内碎片，但是却引入了外碎片。

#### 伙伴系统

固定分区和动态分区都有缺点，所以有了伙伴系统。伙伴系统规定所有分区的大小都是2的k次幂(1<=k<=m)，所以2^1表示最小分区，2^m表示最大分区。

系统开始时，整个内存是2^m的空闲分区，随着系统的运行，会产生若干个不连续的空闲分区，将这些空闲分区按大小进行分类，建立若干个空闲分区双向链表。

此时为一个新的应用程序分配大小为n的存储空间的步骤如下:

1.根据`2^(i－1) <n ≤ 2^i`公式，计算出一个合适的空闲分区大小i，去空闲分区大小为2^i的链表中寻找；

2.如果找到，将其分配。

3.如果没有找到，则去空闲分区大小为2^(i+1)的链表中寻找，如果找到，将该分区分成两个2^i大小的分区，此时这两个分区称为一个伙伴，其中一个负责分配，另一个则加入空闲分区大小为2^i的链表中。

4.如果2^(i+1)的链表也没有找到，则去2^(i+2)的链表中寻找，此时首先将该分区分成两个2^(i+1)大小的分区，一个用户分配，另一个则加入空闲分区大小为2^(i+1)的链表中。将用于分配的2^(i+1)大小的分区分成两个2^i大小的分区，其中一个负责分配，另一个则加入空闲分区大小为2^i的链表中。

5.若还没有找到，则2^(i+3)的链表中寻找，找到后按同样的方法进行分割即可。

所以当将分区进行回收的时候，也可能有多次合并的过程。如回收大小为2^i的空闲分区时，若事先已存在2^i的空闲分区时，则应将其合并为大小为2^(i+1)的空闲分区，若事先已存在2^(i+1)的空闲分区时，继续将其合并为大小为2^(i+2)的空闲分区，依此类推。

### 内存紧凑(memory compaction)

所谓内存紧凑就是消除内存碎片的，将占用的分区往内存的一端移动，从而可以产生一个大的空闲分区，不过移动已占用的内存非常消耗CPU资源。

但是将占用的分区移动后，此时应用程序的地址就需要更新，否则就无法运行。不过更新也很简单，因为程序在装入内存中都是相对地址，等到执行的时候才会映射到物理地址，而映射就是之前所说的使用基址加上相对地址，所以这里紧凑后只需要用应用程序新的起始地址更新基址寄存器即可。

进行内存紧凑的时机有两种，一种是当分区释放后立即内存紧凑，另一种当内存分配找不到合适的空闲分区时进行内存紧凑。

## 覆盖

之前说到了内存抽象满足了多进程的要求，但是如果某个进程的大小比内存还要大(例如游戏)，**覆盖技术**是一种解决这种问题的方法。

所谓覆盖计数就是将程序分为多个块，首先将必要部分的块加载到内存，可选部分在需要时依次加载到内存中。这个方案的最大问题在于要求程序员去给程序进行分块，这是一个复杂耗时的操作，增加了编程的复杂度。

## 虚拟内存

之前的内存分配方式分配的都是一块连续的内存，使用的地址都是物理地址。如果允许分配的内存不连续，这样就可以减少内存碎片同时不需要进行内存紧凑操作。

基于这一思想，就产生了虚拟内存。虚拟内存中，每个进程拥有独立的逻辑地址空间，此时内存按照分配单位的不同，分为页式存储和段式存储。

## 页式存储

## 段式存储

## 总结

## References