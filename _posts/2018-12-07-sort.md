---
layout: post
title:  "排序"
date:   2018-12-07
excerpt:  "本文是笔者总结排序的笔记"
tag:
- Algorithm
comments: true
---

> 笔者最近在刷Leetcode算法题，很多题目都和排序有关，所以在这里笔者将自己对常见排序算法的学习和总结记录下来。

# merge sort

归并排序，时间复杂度为 O(nlogn), 比较高效的一种排序。

思路是：

1. 将一个无序的数组分成均等的两部分，直到仅有一个元素，此时也就是有序了。
2. 当所有小的部分都是有序后，这个时候需要将两边有序的部分合并，重复，最后数组全部有序。

整个过程就如下图所示:

![img_1]({{site.url}}/assets/images/blog/sort_1.png)

> 合并的时候分两种情况，一种新建一个数组进行排序，另一种则不需要新建。

下面是笔者用C++写的一个归并排序, 合并不新建数组:

```
void mergeSort(vector<int>& list) {
    if (list.size() <= 1) { return; }
    auto half = list.size() / 2;
    
    vector<int> left = vector<int>(list.begin(), list.begin() + half);
    vector<int> right = vector<int>(list.begin() + half, list.end());
    
    mergeSort(left);
    mergeSort(right);
    
    auto leftIdx = 0, rightIdx = 0, idx = 0;
    while (leftIdx < left.size() && rightIdx < right.size()) {
        if (left[leftIdx] < right[rightIdx]) {
            list[idx++] = left[leftIdx++];
        } else {
            list[idx++] = right[rightIdx++];
        }
    }
    
    while (leftIdx < left.size()) {
        list[idx++] = left[leftIdx++];
    }
    while (rightIdx < right.size()) {
        list[idx++] = right[rightIdx++];
    }
}

```

时间复杂度，从逻辑上来看，就如上图所示，我们首先进行拆分n个元素，直到元素个数为1，这个过程类似二分查找。

也就是我们每次查找的区间为n，n/2，n/4, ... , n/2^k。 而且 n/2^k 最终会等于1，这个时候也就不能再拆分了，因为只有一个元素了。当 n/2^k = 1 时候， 我们知道 k = log2n, 也就是我们一共需要拆分 log2n次，所以这个拆分的过程的时间复杂度就是 O(logn)。

拆分完之后需要合并有序的段，每次合并需要 O(n) 的时间，一次合并部分有序，经过 O(logn) 次后完全有序，所以整个过程的时间复杂度就是 O(nlogn)。

# quick sort

快速排序，时间复杂度为 O(nlogn)，同样是一种高效的排序方式。

思路如下：

1. 找一个参照数，一般是数组中的元素；
2. 根据参照数，将数组中的元素进行划分，小于参照数的在左边，大于参照数的在右边，等于参照数的位置两边都行；
3. 将两边分别递归调用；

所以上述步骤中第二步骤划分是最重要的，称为`partition`。因为通过这划分步骤我们得到一个位置 p ，根据位置 p 将数组划分为两组进行递归。 

## Hoare

下面笔者介绍 Hoare 版本。Hoare 版本也有两种不同的实现，一种称为'空穴', 另一种则直接交换元素，不产生'空穴'。

- 直接交换元素

```
int myPartition(vector<int>& list, int left, int right) {
    int pivot = list[left];
    int i = left, j = right;
    while (i <= j) {
        while (list[i] < pivot) {
            i++;
        }
        while (list[j] > pivot) {
            j--;
        }
        if (i <= j) {
            swap(list[i], list[j]);
            i++;
            j--;
        }
    }
    return i;
}

void myQuickSort(vector<int>& list, int left, int right) {
    countNumber++;
    int p = myPartition(list, left, right);
    if ((p-1) > left) {
        myQuickSort(list, left, p-1);
    }
    if (p < right) {
        myQuickSort(list, p, right);
    }
}
```

选取一个参照数 pivot，一般选第一个。直接交换元素的方法使用头尾指针 i, j，一个原则就是小于 pivot 的在左边，大于 pivot 的在右边，所以首先过滤左右合法数据（也就是左边小于pivot，右边大于pivot），然后交换一组，小的在左，大的在右，直到 i > j 一次遍历结束。

一次遍历后，将 i 返回，也就是 i 就是上面所说的位置 p。 其实准确的说是两个位置，一个是[left, p1], 另一个是[p, right]。p1 等于 p-1, p2 等于 p。 这里需要判断 p1 和 p2 的合法性，所以递归之前需要和 left 和 right 比较。

每一次partition可以说是让数组部分有序，之后将数组拆分两部分，继续使其有序，直到不能拆分，最后结束数组中的元素自然就全部有序了。

上面的 `myPartition` 其实不唯一，比如下面这个 `myPartitionVersion2` 同样也是有效的，不管怎样，目标就是返回一个拆分数组的位置 p.

```
int myPartitionVersion2(vector<int>& list, int left, int right) {
    int pivot = list[left];
    int i = left, j = right;
    while (1) {
        while (list[i] < pivot) {
            i++;
        }
        while (list[j] > pivot) {
            j--;
        }

        if (i == j) {
            return i;
        } else if (i > j) {
            return i-1;
        }

        swap(list[i], list[j]);
        i++;
        j--;
    }
}
```

- 空穴

```
int partition(vector<int>& list, int left, int right) {
    int pivot = list[left];
    int i = left, j = right;
    while (i < j) {
        while (i < j && list[j] >= pivot) {
            j--;
        }
        if (i < j) { list[i] = list[j]; }
        
        while (i < j && list[i] <= pivot) {
            i++;
        }
        if (i < j) { list[j] = list[i]; }
    }
    list[i] = pivot;
    return i;
}

void quickSort(vector<int>& list, int left, int right) {
    if (left >= right) {
        return;
    }
    int p = partition(list, left, right);
    quickSort(list, left, p-1);
    quickSort(list, p+1, right);
}
```

空穴方法首先还是选定一个参照数 pivot = list[left], 左右两个指针 i, j，也就是说我们将数组中第一个元素作为一个参照数，同时将其存放起来了。

现在数组中第一个数字的位置等于一个空穴，这个时候我们从后往前找一个小于等于 pivot 的数，如果找到将其放进空穴，放完以后空穴就成了存放刚刚那个数字的位置。

这个时候从前往后找一个大于等于 pivot 的数字，将其放进空穴，循环，直到左右两个指针相等停止，将 pivot 的数字放到 指针停止的位置。此时返回 i 。

得到 p 后 ，此时我们只需要递归的使 [left, p-1] , [p+1, right] 有序，那么整个数组也就有序了。

> 唯一需要注意的是，这里我们移动指针的时候，当数字等于 pivot 时候， 我们也移动了指针，因为如果数组中有重复元素，没有移动指针就会死循环。

## Lomuto

Lomuto 也是一种 partition 的方式。

```
int partition_lomuto(vector<int>& list, int left, int right) {
    int pivot = list[right];
    int i = left;
    for (int j = left; j < right; ++j) {
        if (list[j] < pivot) {
            if (i != j) {
                swap(list[i], list[j]);
            }
            i++;
        }
    }
    if (i == right) {
        return i-1;
    } else {
        swap(list[i], list[right]);
        return i;
    }
}

void quickSortVersion4(vector<int>& list, int left, int right) {
    if (left >= right) {
        return;
    }
    countNumber++;
    int p = partition_lomuto(list, left, right);
    quickSortVersion4(list, left, p);
    quickSortVersion4(list, p+1, right);
}
```

这种 partition 的方式选取的参照数是最右边的，同时设定一个指针在最左边 i ，然后一个循环 j 从头开始，当循环的位置的数字小于 pivot ，同时 i 不等于 j 的时候交换位置，因为此时 j 所在的数字是小于 pivot 而 i 所在的位置是大于 pivot 的。

如果 i 等于 right， 此时说明 right 所在的数字就是这组数字中最大的，所以直接返回 i - 1。

如果 i 小于 right， 此时需要交换 i 和 right 对应位置的数字，将 i 所在 数字 大于 pivot 的放在数组后面，返回 i。

最后 只需要 递归 [left, p], [p+1, right] 即可。

# bubble sort

冒泡排序笔者在大学C语言课程中就学过，主要思路是每次将数组中最大的数放到最后，直到数组有序。

可以加一个 flag 来判断数组是否为有序的，因为至少会走一趟排序，当没有进行交换元素，说明此时数组就是有序的，接下来的排序就不需要了。

```
void bubbleSort(vector<int>& list) {
    int count = (int)list.size();
    bool swapped;
    for (int i = 0; i < count-1; ++i) {
        swapped = false;
        for (int j = 0; j < count-i-1; ++j) {
            if (list[j+1] < list[j]) {
                swap(list[j+1], list[j]);
                swapped = true;
            }
        }
        if (swapped == false) {
            break;
        }
    }
}
```

两个循环，第一个循环表示的需要比较的趟数，n 个 数 只需要 比较 n-1 趟，因为一个数时并不需要比较了。

第二个循环因为已经有 i 个最大的在后面，所以循环次数额外减去 i。