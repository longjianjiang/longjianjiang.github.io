---
layout: post
title:  "排序"
date:   2018-12-07
excerpt:  "本文是笔者总结排序的笔记"
tag:
- Algorithm
comments: true
---

> 笔者最近在刷Leetcode算法题，很多题目都和排序有关，所以在这里笔者将自己对常见排序算法的学习和总结记录下来。

# merge sort

归并排序，时间复杂度为 O(nlogn), 比较高效的一种排序。

思路是：

1. 将一个无序的数组分成均等的两部分，直到仅有一个元素，此时也就是有序了。
2. 当所有小的部分都是有序后，这个时候需要将两边有序的部分合并，重复，最后数组全部有序。

整个过程就如下图所示:

![img_1]({{site.url}}/assets/images/blog/sort_1.png)

> 合并的时候分两种情况，一种新建一个数组进行排序，另一种则不需要新建。

下面是笔者用C++写的一个归并排序, 合并不新建数组:

```
void mergeSort(vector<int>& list) {
    if (list.size() <= 1) { return; }
    auto half = list.size() / 2;
    
    vector<int> left = vector<int>(list.begin(), list.begin() + half);
    vector<int> right = vector<int>(list.begin() + half, list.end());
    
    mergeSort(left);
    mergeSort(right);
    
    auto leftIdx = 0, rightIdx = 0, idx = 0;
    while (leftIdx < left.size() && rightIdx < right.size()) {
        if (left[leftIdx] < right[rightIdx]) {
            list[idx++] = left[leftIdx++];
        } else {
            list[idx++] = right[rightIdx++];
        }
    }
    
    while (leftIdx < left.size()) {
        list[idx++] = left[leftIdx++];
    }
    while (rightIdx < right.size()) {
        list[idx++] = right[rightIdx++];
    }
}

```

时间复杂度，从逻辑上来看，就如上图所示，我们首先进行拆分n个元素，直到元素个数为1，这个过程类似二分查找。

也就是我们每次查找的区间为n，n/2，n/4, ... , n/2^k。 而且 n/2^k 最终会等于1，这个时候也就不能再拆分了，因为只有一个元素了。当 n/2^k = 1 时候， 我们知道 k = log2n, 也就是我们一共需要拆分 log2n次，所以这个拆分的过程的时间复杂度就是 O(logn)。

拆分完之后需要合并有序的段，每次合并需要 O(n) 的时间，一次合并部分有序，经过 O(logn) 次后完全有序，所以整个过程的时间复杂度就是 O(nlogn)。


