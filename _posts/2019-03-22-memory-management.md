---
layout: post
title:  "内存管理学习笔记"
date:   2019-03-22
excerpt:  "本文是笔者学习内存管理的笔记"
tag:
- OS
comments: true
---

> 内存管理是一个很基础的问题，本文笔者记录下自己的总结过程。本文中所讨论的内存是进程运行时动态分配的，这一部分内存存放在进程的堆段。

不论我们如何对内存进行管理，我们都得向操作系统申请内存，所以首先需要了解操作系统是如何进行管理内存的。这部分内容可以参考[这里](http://www.longjianjiang.com/os-memory-management/)。

## malloc & free

> 这里不会深入malloc和free的实现，具体实现可以参考[这里](http://www.longjianjiang.com/malloc-free-detail/)。

`malloc` 方法笔者第一次接触是在大学C语言中，知道这个方法是向操作系统申请n个字节的内存，并返回这一段连续内存的首地址，如果失败则返回NULL。

有使用对应的就会有释放，`free` 就是来释放之前向操作系统申请的那一段内存。

现在让我们想一个问题，`free` 方法仅接收一个首地址，它是如何知道释放多长的内存的？

其实这个解决方案不唯一，有的malloc的实现内部将分配的内存size进行分组，根据传入的size返回合适的size的内存段。

还有一种实现则是增加一个结构体用来存储分配的size，所以malloc方法返回的地址其实就是结构体的地址往前偏移了结构体size的一个新的地址，所以free的时候只需要将这个地址往后编译结构体size就得到了结构体的地址，通过结构体地址自然也就知道了当初申请内存的大小。

其实不光有malloc，还有 `realloc` 这个方法的作用是当 `malloc` 分配的内存不够使用时，使用`realloc`可以重新申请连续size个内存空间。

其实我们绝大多数情况下不会直接使用这类分配内存的方法，因为这种方式对程序员的要求比较高，程序员必须时刻关注内存的使用情况，当这部分内存不再使用的时候将内存进行释放。这里的难点在于内存的使用情况可能是整个程序的任意地点的任意运行期间，而我们调用内存管理方法的时候仅仅是根据当前上下文来进行的，所以何时free是一个问题。

如果提前释放了未来还将继续使用的内存，那么访问时结果就未定义；或者未释放不再使用的内存，则会导致内存泄露。所以为了让程序员可以专注于任务的开发，有了下面几种更加自动的内存管理方式。

## 引用计数

引用计数是一种半自动的内存管理方式，这种方式会增加一个引用计数的变量，同时存在两个方法增加引用计数和减少引用计数，减少引用计数后会检查是否为0，决定是否free。可以看到使用这种方式程序员只需要管理好内存的引用计数即可，释放的事情这个机制会自动进行。

引用计数的具体实现同样是不唯一的，一种方式是使用结构体，结构体中存储来这块内存的引用计数变量，返回的内存地址其实就是结构体的指针。所以操作引用计数直接操作结构体的成员即可。

另一种方式则不使用结构体，首先会申请一大块内存，同时使用bitmap的方式来记录这块内存的使用情况。按照一定的规则初始化bitmap，bitmap中的位就代表来一段内存的使用情况，操作引用计数其实就是操作bitmap中的位。

这两种方式各有优缺点，第一种方式的优点在于实现相对简单而且不存在内存碎片，缺点在于需要频繁的去调用内存申请的方法。第二种方式的优点在于性能更加高效，因为实现分配的一大片内存从而不需要频繁的申请，缺点在于实现复杂可能存在内存碎片。

虽然使用引用计数可以提高内存使用效率，方便程序员使用，但是这种方式还是有一些缺点的，列举如下:

1.存在循环引用的情况，当需要回收A的内存时，此时A拥有B的使用权，所以此时只要等B被回收的时候，A才能被回收，如果这个时候B也拥有A的使用权，此时B不能被回收，所以导致了AB都不能被回收。解决办法也很简单，让AB协调，只要其中一个拥有对方的使用权即可。

2.因为存在引用计数同时需要维护引用计数，所以不可避免的消耗了额外的内存。

3.在多线程环境下，对引用计数的操作不可避免的需要进行加锁操作，从而可能会对性能有所影响。

## 内存池

内存池同样也是一种半自动的内存管理方式。内存池是用来代替之前所说的`malloc`, `free`方法的，我们需要内存的时候直接向内存池申请，由于内存池预先会申请并管理一块内存，所以申请释放的速度比直接使用`malloc`, `free`要快的多。

内存池根据不同的使用场景有不同的种类，主要是线程安全和内存单元两个方面。线程安全不多说，内存单元则是指内存池可以是固定size的或者是可变size的。

内存池的设计同样有多种的方式，业界有Apache服务器的内存池，是一个通用的内存池的实现。

由于笔者并没有设计内存池的经验，在此就不过多叙述，这里只是简单的介绍内存池的原理。

## 垃圾回收

前面不论是内存池、引用计数或者是`malloc`, `free`方法，都需要我们关注内存的申请和释放，而垃圾回收机制则让我们完全不用关注这些。垃圾回收机制会在内存降低到某个临界点的时候去回收内存进行释放，所以垃圾回收是一种自动的内存管理方式。

现在让我们想一个问题，垃圾回收机制是如何知道一块内存是不再使用从而进行回收的呢？

一种方式依然是基于引用计数来判断内存的使用情况。

另一种方式通过标记清除，垃圾回收机制通过进程中一些存储区域(例如线程栈，静态存储区域，寄存器等)作为根节点开始递归的标记任意自己引用到的对象为存活对象，标记完成后，对象之间的引用关系构成一个有向图，对象是图中的节点，而引用关系则是图的边。标记完成后，从根节点开始遍历，被标记的对象也就是存活对象，而没有被标记的对象则可以进行回收，这一操作就称为清除。同时在遍历的过程中需要将存活对象的标记清除，为下一次垃圾回收做准备。这样就可以实现内存的有效回收，同时可以回收循环引用的内存。

上面提到的标记清除的方式当分配大量对象但是存活的对象比较少的情况下，此时就会消耗很多时间，因为在遍历阶段需要遍历整个图来找到未标记的对象，从而进行回收。一种复制算法就是来解决这个问题的，使用该算法需要两块相同大小的内存区域，将从根节点可以到达的节点复制到另一个区域to，然后回收当前区域from，之后两块内存区域互换角色。

还存在一种压缩算法，因为由于对象的清除可能导致内存碎片的产生，所以压缩算法需要做的事情就是将存活对象移动到一起来获得一段连续的内存空间，此时需要要所有对象的指针地址进行重定位。

> 上述垃圾回收算法运行的时候需要将进行完全暂停，为了保持一个一致的状态来进行回收。称之为STW(Stop The World)。

分代收集是一个比较新的垃圾回收方案，它基于一个假设：大多数对象很快就会死亡。所以分代收集将内存分为年轻代(占小部分空间)和老年代两个区域，新创建的对象首先存放在年轻代，把年轻代中存活时间很长的对象移动到老年代，而老年代区域只要满了才会去收集。

实际的垃圾回收的实现可能是上述多种不同的算法的组合，以应对不同的情况，这里笔者就不过多叙述，具体可以参考JVM的垃圾回收机制。

同样的垃圾回收同样有一些缺点:

1.无法判断内存何时被释放

2.垃圾回收的速度一般较慢

3.出现bug的时候难以调试

## iOS中的内存管理

iOS之前是MRC也就是之前说的引用计数，后面到了ARC其实还是引用计数，只是我们不需要再去写操作引用计数的方法，由编译器帮我们处理了。OC中的引用计数的实现参考[这里](http://www.longjianjiang.com/runtime-source-code-reference-counting/)。

### MRC

iOS使用引用计数的方式来进行内存管理，提供了 `retain` 增加引用计数的方法，`release` 减少引用计数的方法。所以实际使用中我们如果需要使用某个对象，就调用`retain` 方法，使用完毕后调用 `release` 方法。

Apple实现引用计数的方式使用来散列表，key是对象的地址，value则是对象的引用计数。用这样一个结构来管理引用计数的一个好处在于可以方便的根据散列表追踪到对象的内存区域。

除此之外还提供了`autorelease` 的功能，当一个对象调用了该方法，会将该对象加入到池中，当包含该对象的池释放时，会将池中包含的对象释放。关于 `autorelease` 的更多内容可以看[这里](http://www.longjianjiang.com/runtime-source-code-autorelease/)。

### ARC

因为MRC时代，程序员需要手动写很多操作引用计数的方法，所以Apple推出了ARC，这部分代码由编译器会在合适的位置帮我们生成，我们就不用去手写了。

ARC机制多了一个所有权修饰符的概念，默认所有引用默认都是使用 `__strong` 修饰符。当一个指针指向一个对象，其实也就是堆上的一块连续内存，此时这个对象就会一直存活，当该指针变量超过作用域时，指针被废弃，此时堆上的内存没有指针指向了，这个时候这块内存就会被回收。

因为使用引用计数会产生循环引用的问题，所以ARC中提供了一个 `__weak` 修饰符，该修饰符表示不会持有某个对象，也就是说该修饰符并不会影响对象的引用计数，这样当出现互相引用的时候，指定其中一个为`__weak`即可打破循环。

因为`__weak` 修饰符在iOS5中提供，所以之前如果需要指定不持有某个对象，就需要使用`__unsafe_unretained`修饰符。使用这个修饰符其实就是告诉编译器，这个对象的内存管理不需要你管了。

最后还有一个 `__autoreleasing` 修饰符，使用该修饰符修饰的对象，效果和调用`autorelease`方法一样。下面有几种特殊的情况，即使你没有用这个修饰符，但是依然可以将对象加入到池中。

第一种情况是函数返回值，作为函数返回值的对象，经笔者实验，会将该对象加入池中，直到池释放，该对象才会被释放。

> 这里需要注意的是这里的函数不是实际做分配对象的函数，也就是除了allow/new/copy/mutableCopy以外的函数，因为这几个函数的作用就相等于是分配内存，初始化引用计数，所以此时还不需要进行管理引用计数。

第二种情况是二级指针对象，默认使用的就是`__autoreleasing` 修饰符，此时经笔者实验，会将该二级指针指向的对象加入池中，直到池释放，该对象才会被释放。

> 不论该二级指针对象是以函数参数的形式，还是直接使用，都会将其指向的对象加入池中。

Apple通过这几个修饰符来确定在合适的位置上添加MRC中操作引用计数的方法，从而正确的进行内存管理。

这里的ARC中几个所有权修饰符，其实和C++中的智能指针很像，C++中有三种智能指针，下面笔者进行简单的介绍。

- unique_ptr

`unique_ptr`只能指向一份资源，不能使用两个`unique_ptr`指向同一份资源(不支持拷贝构造和赋值操作)，当`unique_ptr`指针销毁时，被管理的资源也被销毁。

- shared_ptr

`shared_ptr` 使用引用计数来管理内存，就类似之前说的`__strong` 修饰符的对象。

- weak_ptr

`weak_ptr` 用来指向一个`shared_ptr`，但不影响引用计数，类似之前说的`__weak` 修饰符的对象。

## 总结

从上面的种种内存管理方式来看，再一次验证了那句经典的**没有银弹**。这也解释了为什么有的语言使用了GC，有些语言并没有GC，就算同样使用GC的语言，GC内部的实现也不一样。

## References

[https://www.ibm.com/developerworks/linux/library/l-memory/](https://www.ibm.com/developerworks/linux/library/l-memory/)

[https://opensource.apple.com/source/libmalloc/libmalloc-53.1.1/src/malloc.c.auto.html](https://opensource.apple.com/source/libmalloc/libmalloc-53.1.1/src/malloc.c.auto.html)

[https://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html](https://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html)

[iOS与OS X多线程和内存管理](https://book.douban.com/subject/24720270/)


