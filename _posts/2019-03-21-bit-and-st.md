---
layout: post
title:  "二叉索引树&线段树"
date:   2019-03-21
excerpt:  "本文是笔者学习二叉索引树&线段树的笔记"
tag:
- Algorithm
comments: true
---

## 引子

笔者在做LeetOJ题时遇到了一道求数组范围的题[307](https://leetcode.com/problems/range-sum-query-mutable/),题目大意：给定数组，新建一个类，对数组进行range求和以及更新数组，这两个操作比例均等。类模版如下所示:

{% highlight cpp %}
class NumArray {
public:
    NumArray(vector<int> nums);
    void update(int i, int val);
    int sumRange(int i, int j);
};
{% endhighlight %}

可以看到我们需要做的两个操作就是update和sumRange，一种直接的方法其实就是求和的时候，遍历数组从i到j依次叠加即可，更新则使用下标更新。或者提高求和效率，额外维护一个数组arr，arr[2]表示为原数组0-2的范围和。

但是这两种方法在求和和更新操作比例相等的情况下不是最佳，有没有让求和更新操作的时间复杂度都为O(logN)呢？所以依旧我们需要用空间换时间，下面的两种数据结构就是解决这类问题的。

## 二叉索引树

二叉索引树其实实现很简单，主要利用了元素索引的二进制的形式来确定二叉索引树中的位置，适用于区间求和问题，实际存储是用数组来存的。

下面给定数组 [1, 2, 3, 4, 5], 构建一个二叉索引树，

```
二叉树形式(x代表没有元素)：

	       10
	     /	  \
	    3	    x
       / \     / \
      1	  3   5   x
idx:0 1 2 3 4 5 6 7 
-----------------------

实际数组存储形式：

[1, 3, 3, 10, 5]
```

> 二叉索引树的索引从1开始；

上述二叉树有三层，叶子节点所在层索引为`1(0001),3(0011),5(0101),7(0111)`，这四个索引的二进制形式最低位的1处于从低位开始的第一位。这一层的节点可以看到存储的就是原数组(索引为[0,2,4])中对应的元素。

第二层为`2(0010),6(0110)`, 这两个索引的二进制形式最低位的1处于低位开始的第二位。树索引为2的节点存储的其实是原数组索引0-1的和也就是3。

最高层为`4(0100)`，这索引的二进制形式最低位的1处于低位开始的第三位。这一层的节点存储的其实是原数组索引0-3的和也就是10。

根据上述分析，可以得到一个根据原数组构建二叉索引树的规律，找到当前节点递归左子树直到叶子节点的索引，从该索引开始到当前节点索引结束，将这一范围对应原数组元素的和存储到二叉索引树中即可。

这里有一个问题，给定一个节点索引如何知道其递归左子树直到叶子节点的索引，这里就需要用到二进制位运算了。

首先一个基本的运算，获取索引最低位的1的值，我们称之为`lowbit(i)`，其实很简单`i &= -i`即可，其实就是用到了补码，取反加1，这个1肯定就是在最低位，这样&时就只保留了最低位的1。

有了lowbit我们可以很容易的根据索引获取到该节点一些关系节点，如下所示:


我们也就得到了根据原数组构建二叉索引树的公式:

```
bit[i] = arr[j] + ... + arr[i]; // j = i - lowbit(i) + 1
```


根据以上的观察，其实可以看到一个规律，树中每个节点所存储的元素其实是当前元素及其左子树的和。

拿索引4也就是树中存储10的节点来说，这个节点存储的是原数组索引0-3的和，首先索引4的当前元素对应原数组中索引为3的元素值为4，所以该节点的左子树的和为应该是6。左子树也就是索引为2树中存储3的节点，同样的规则，索引2节点的当前元素对应原数组中索引为1的元素为2，而索引2节点的子树为索引1节点，索引1节点为叶子节点存储的值为1，所以`1+2`索引2节点的值是3。回到索引4节点的左子树，经过之前的分析，索引2节点的左子树加上索引2节点的和其实就是索引2节点存储的值，所以此时只需要再加上索引2节点的右子树的值就可以得到索引4节点左子树的和，而索引2节点的右子树也为叶子节点值为3，`3+3`和正好为6。




知道了二叉索引树索引的二进制最低位1的形式规律后，下面我们看如何生成二叉索引树中每个节点中的元素。
## 线段树
