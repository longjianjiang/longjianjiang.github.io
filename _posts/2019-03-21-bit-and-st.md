---
layout: post
title:  "二叉索引树&线段树"
date:   2019-03-21
excerpt:  "本文是笔者学习二叉索引树&线段树的笔记"
tag:
- Algorithm
comments: true
---

## 前缀和

所谓前缀和就是新建一个数组来存储原数组的前n个元素的和，通过这样一个额外的数组，可以快速的获得数组中任意区间的和。

一般为了索引的有效性，前缀和长度是原数组长度nsize加1，这样原数组的任意区间(l, r)[0, nsize)等于 prefix[r+1] - prefix[l]。

```
idx     :   [0, 1, 2, 4, 5]
nums    :   [1, 2, 3, 4, 5]

prefix1 :[0, 1, 3, 6, 10, 15]

range(1, 2) = nums[1] + nums[2] = 5;
            = prefix1(3) - prefix1(1) = (nums[0] + nums[1] + nums[2]) - (nums[0]) = nums[1] + nums[2];

所以看到range(1, 2) 其实是前3个数组元素的和 - 前1个数组元素的和 等于 第一个元素 加 第二个元素的和。
```


## 引子

笔者在做LeetOJ题时遇到了一道求数组范围的题[307](https://leetcode.com/problems/range-sum-query-mutable/),题目大意：给定数组，新建一个类，对数组进行range求和以及更新数组，这两个操作比例均等。类模版如下所示:

{% highlight cpp %}
class NumArray {
public:
    NumArray(vector<int> nums);
    void update(int i, int val);
    int sumRange(int i, int j);
};
{% endhighlight %}

可以看到我们需要做的两个操作就是update和sumRange，一种直接的方法其实就是求和的时候，遍历数组从i到j依次叠加即可，更新则使用下标更新。或者提高求和效率，额外维护一个数组arr，arr[2]表示为原数组0-2的范围和。

但是这两种方法在求和和更新操作比例相等的情况下不是最佳，有没有让求和更新操作的时间复杂度都为O(logN)呢？所以依旧我们需要用空间换时间，下面的两种数据结构就是解决这类问题的。

## 二叉索引树

二叉索引树其实实现很简单，主要利用了元素索引的二进制的形式来确定对应节点在二叉索引树中的位置，适用于区间求和问题，实际存储是用数组来存的。

下面给定数组 [1, 2, 3, 4, 5], 构建一个二叉索引树，

```
二叉树形式(x代表没有元素)：

	       10
	     /	  \
	    3	    x
       / \     / \
      1	  3   5   x
idx:0 1 2 3 4 5 6 7 
-----------------------

实际数组存储形式：

[1, 3, 3, 10, 5]
```

> 二叉索引树的索引从1开始；

上述二叉树有三层，叶子节点所在层索引为`1(0001),3(0011),5(0101),7(0111)`，这四个索引的二进制形式最低位的1处于从低位开始的第一位。这一层的节点可以看到存储的就是原数组(索引为[0,2,4])中对应的元素。

第二层为`2(0010),6(0110)`, 这两个索引的二进制形式最低位的1处于低位开始的第二位。树索引为2的节点存储的其实是原数组索引0-1的和也就是3。

最高层为`4(0100)`，这索引的二进制形式最低位的1处于低位开始的第三位。这一层的节点存储的其实是原数组索引0-3的和也就是10。

根据上述分析，可以得到一个根据原数组构建二叉索引树的规律，找到当前节点递归左子树直到叶子节点的索引，从该索引开始到当前节点索引结束，将这一范围对应原数组元素的和存储到二叉索引树中即可。

这里有一个问题，给定一个节点索引如何知道其递归左子树直到叶子节点的索引，这里就需要用到二进制位运算了。

首先一个基本的运算，获取索引最低位的1的值，我们称之为`lowbit(i)`，其实很简单`i &= -i`即可，其实就是用到了补码，取反加1，这个1肯定就是在最低位，这样&时就只保留了最低位的1。

有了lowbit我们可以很容易的根据索引获取到该节点一些关系节点，如下所示:

```
假设二叉索引树中一节点索引为i：

i-lowbit(i)		: 左祖父/父节点
i+lowbit(i)		: 右祖父/父节点
i-lowbit(i)+1	: 递归左子树直到叶子节点
```

有了上述的节点关系，我们也就得到了根据原数组构建二叉索引树的公式:

```
bit[i] = arr[j] + ... + arr[i]; // j = i - lowbit(i) + 1
```

根据上面公式，其实可以看到一个规律，树中每个节点所存储的元素其实是当前元素及其左子树的和。

拿索引4也就是树中存储10的节点来说，这个节点存储的是原数组索引0-3的和，首先索引4的当前元素对应原数组中索引为3的元素值为4，所以该节点的左子树的和为应该是6。左子树也就是索引为2树中存储3的节点，同样的规则，索引2节点的当前元素对应原数组中索引为1的元素为2，而索引2节点的子树为索引1节点，索引1节点为叶子节点存储的值为1，所以`1+2`索引2节点的值是3。回到索引4节点的左子树，经过之前的分析，索引2节点的左子树加上索引2节点的和其实就是索引2节点存储的值，所以此时只需要再加上索引2节点的右子树的值就可以得到索引4节点左子树的和，而索引2节点的右子树也为叶子节点值为3，`3+3`和正好为6。

综上，现在我们只需要完成更新和求区间和两个操作，那么构建二叉索引树的工作也就完成了。

- 更新

现在让我们来看更新操作，我们根据之前的构建二叉树的公式可以知道，我们如果更新了树中某个节点，必然需要去更新该节点的父节点或者右祖父。

拿索引为1的节点来说，当该节点更新后，必然需要更新索引为2的节点，也就是父节点；

拿索引为3的节点来说，当该节点更新后，必然需要更新索引为4的节点，也就是其右祖父节点；

而根据节点之间的关系，我们可以通过`i+lowbit(i)`来获取当前节点的父节点或者右祖父节点，最后判断索引是否越界即可。更新操作参考代码如下：

{% highlight cpp %}
template <typename T>
void binary_indexed_tree<T>::update(size_t leaf_index, const T &update_value) {
    if (arr && leaf_index+1 < capacity) {
        T diff = update_value - data[leaf_index];
        size_t idx = leaf_index+1;
        while (idx < capacity) {
            arr[idx] += diff;
            idx += idx & (-idx);
        }
        data[leaf_index] = update_value;
    }
}
{% endhighlight %}

- 求和

最后我们来看求和操作，依然根据之前的构建二叉树的公式可以知道，树的某个节点存储的是其当前元素及其左子树的和，所以在求区间和的时候，必然需要去查询其父节点或者其左祖父的值进行相加。

求数组区间[0-2]的和，索引为3的节点的父节点就是索引为2的节点，该节点存储的就是区间[0-1]的和，所以返回b
it[2]+bit[3]即可；

求数组区间[0-4]的和，索引为5的节点的左祖父就是索引为4的节点，该节点存储的就是区间[0-3]的和，所以返回bit[4]+bit[5]即可；

而根据节点之间的关系，我们可以通过`i-lowbit(i)`来获取当前节点的父节点或者左祖父节点，最后判断索引是否大于0即可。更新操作参考代码如下：

{% highlight cpp %}
template <typename T>
T binary_indexed_tree<T>::get_sum_until(size_t leaf_index) {
    if (leaf_index + 1 < capacity) {
        T res = initial_value();
        size_t idx = leaf_index + 1;
        while (idx) {
            res += arr[idx];
            idx -= idx & (-idx);
        }
        return res;
    } else {
        return null_value();
    }
}
{% endhighlight %}

	
参考实现点击[这里](https://github.com/longjianjiang/Algorithms/blob/master/data_structures/binary_indexed_tree.h)

## 线段树

线段树是一颗完全二叉树，根据区间进行拆分数组，最终叶子节点存储的就是原数组中的元素，而其他的父节点则是某个区间，存储的也是该段区间元素的和。

> 线段树不仅仅可以求解区间和的问题，而且适用于其他的区间问题，比如区间中的最值，总而言之，求区间关系的问题都可以使用线段树。

下面给定数组 [1, 2, 3, 4, 5], 构建一个线段树：

```
				        [0, 4]
				         (15)
		            /			 \
	            [0,2]			 [3,4]
	             (6)			  (9)
	           /     \          /     \
           [0,1]     [2,2]  [3,3]     [4,4]
            (3)       (3)    (4)       (5)
         /      \
     [0,0]      [1,1]
      (1)        (2)
```

可以看到，根节点是整个数组的区间，两颗子树是二分后的两个区间，接下来的依然进行二分，直到叶子节点，此时的区间就是某个元素。构建一颗线段树有三个步骤，建树，更新，查询。

参考实现点击[这里](https://github.com/longjianjiang/Algorithms/blob/master/data_structures/segment_tree.h)