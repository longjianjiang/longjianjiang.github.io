---
layout: post
title:  "异步学习笔记"
date:   2019-05-09
excerpt:  "本文是笔者学习异步的笔记"
tag:
- OS
comments: true
---

之前对异步同步的理解不是那么的准确，本文笔者会将自己对异步同步的理解记录下来。

## block & nonblock

在说sync,async 之前先提一个阻塞的概念，大多数情况下说到sync，async都会涉及到阻塞。

阻塞的对象无非是进程或者线程，线程和进程都会有三种状态：就绪，执行，阻塞。

- 阻塞

进程或者线程执行过程中被挂起，进入**阻塞**的状态。

- 非阻塞

进程或者线程正常执行。

## 一个例子

这个例子会给出下面需要讨论的几种不同的执行方式，现在对例子本身有个概念就好：

老张爱喝茶，废话不说，煮开水。

出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。

1 老张把水壶放到火上，立等水开。（同步阻塞）；立等就是阻塞了老张去干别的事，老张得一直主动的看着水开没，这就是同步；

2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）；老张去看电视了，这就是非阻塞了，但是老张还是得关注着水开没，这也就是同步了；

3 老张把响水壶放到火上，立等水开。（异步阻塞）；立等就是阻塞了老张去干别的事，但是老张不用时刻关注水开没，因为水开了，响水壶会提醒他，这就是异步了；

4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）；老张去看电视了，这就是非阻塞了，而且，等水开了，响水壶会提醒他，这就是异步了；

---

## sync & async

根据前面的例子，其实可以发现同步异步的区别在于调用者如何得到被调用者结果的方式。

同步：调用者会等待被调用者完成后，拿到结果；

异步：被调用者在完成后通过某种方式通知调用者，附带上结果；

还是上面的例子，我们可以发现，同步异步和阻塞非阻塞没有关联，是两个维度的概念，不要混淆。

同步不一定阻塞，异步也不一定非阻塞。

## 异步

同步阻塞应该是最常见的，笔者写的第一个hello world，就是这种执行方式。

根据例子中的第一种情况，很直观的发现，这种方式是有问题的。是的，在进行IO操作的时候，这种方式就不适用了。

下面笔者从两个方面来说明进行IO操作采用同步阻塞操作的问题。

> 首先从阻塞的方面来说：

笔者先介绍几种IO模型，假设`read`是一个IO操作：

### 阻塞IO

当调用read后，read不会返回，直到读操作完成后返回，这个时候拿到数据去做下一步操作。

这个时候的问题是，当前线程只能进行了一次read操作，就干不了其他事情了。

### 非阻塞IO

为了可以进行多次read操作，这个时候read做了一个改变，当读操作没有完成的时候，返回一个错误。

当调用read后，每次检查数据是否完成，发现完成后，拿到数据进行下一步操作，这个时候就是一个忙等的方式。

这个时候的问题是，如果read操作耗时很长，那么忙等会白白的消耗CPU资源。

### IO多路复用

为了不消耗CPU资源，这个时候内核中引入了一个代理，让这个代理来告诉我们数据是否完成。

当某个read操作完成后，会收到一个通知，这个时候再去进行下一步操作。

具体可以参考`select`,`poll`,`epoll`。

非阻塞IO和IO多路复用，就是例子中的同步非阻塞的方式。根据例子，我们发现这种方式还是不够完美。

> 从异步方面来说：

上面的方式虽然没有阻塞，但是依然只能做read操作这一件事，导致这个问题的关键就在于，之前的方式在主动的等待read操作完成的结果，所以更好的方式就是让别人来告诉我read操作的结果。

这里以操作系统中的IO控制方式来说，早期操作系统对IO设备的控制采取忙等的方式，类似之前说的非阻塞IO。

当操作系统有了中断后，就不需要忙等方式了，而是采用中断控制的方式。当某个进程需要某个IO设备数据时，CPU会将对应的IO设备控制器发送一条指令，然后继续执行接下来的指令。这个时候IO设备控制器会去操作对应的IO设备，此时CPU和IO设备并行（异步），当IO设备数据准备完成后，IO设备控制器发送中断信号给CPU，这个时候CPU保存运行上下文后，去处理中断，处理完毕后，恢复中断之前的状态继续执行。

所以这种中断控制的方式就是异步非阻塞。

## 异步的实现

callback的方式应该是异步最常见的实现了。

通过callback的方式告知调用者调用完成（异步），如果新建线程执行（非阻塞），当前线程执行（阻塞）。

如果这个调用是IO操作，那么还需要一个event loop，这个event loop运行在一个线程中。

这个时候一个异步IO操作会带上一个callback，调用后立即返回，具体执行则是在子线程中，当子线程中IO操作执行完成后，发送一个完成事件，event loop 在某次循环中执行该异步操作的callback即可。

如果这个调用不是IO操作，那么也就没有必要使用异步了。使用异步通常都是因为调用链的底端有一个IO操作。

## 总结

笔者之前对异步的理解不是那么正确，本文算是自己一个小小的学习总结。

## References

[https://segmentfault.com/a/1190000003063859#articleHeader10](https://segmentfault.com/a/1190000003063859#articleHeader10)

[https://www.zhihu.com/question/19732473](https://www.zhihu.com/question/19732473)

[http://luoxia.me/code/2016/08/16/%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/](http://luoxia.me/code/2016/08/16/%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/)

[https://www.dazhuanlan.com/2020/01/02/5e0d883dd79c3/](https://www.dazhuanlan.com/2020/01/02/5e0d883dd79c3/)
