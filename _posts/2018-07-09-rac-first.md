---
layout: post
title:  "【Reative】学习笔记第一弹"
date:   2018-07-09
excerpt:  "本文是笔者学习Reative的第一篇文章，主要介绍一些基本概念"
tag:
- Reative
comments: true
---


> 说起`Reative`，相信大家一定都不陌生，iOS当中的代表应该是 `ReactiveCocoa`,RAC今天看来已经非常基础了，【Reative】系列文章，笔者打算将自己学习的思路记录下来；


不论当前的`RxSwift`, `ReactiveSwift` 或者 之前的`ReactiveCocoa`, 它们的实现是类似的，思想也是共同的，所以当我们学习这种响应式框架的时候，我们开始最重要的是理解其中的一些基本概念，这对后面的实践是有很大帮助的。 下面笔者以自身学习为例，介绍几个基本概念。



## Side Effects

我们可能在学习`Reative`的时候，多少会看到所谓的Side Effects,`比如当信号被订阅的时候副作用就会发生等等类似的句子`。
举个例子，下面代码中的add函数就产生了副作用，因为它在函数执行中改变了全局变量的值。

```
$global_val = 0

def add(a, b)
  $global_val = 2
  a + b 
end

puts add 5, 7
puts "global_val is #{$global_val}"
```

所以所谓的副作用就是函数或者程序在执行过程中改变了自身以外的其他人的状态，这就可以叫产生副作用了。
回到`比如当信号被订阅的时候副作用就会发生等等类似的句子`, 因为订阅执行时会改变外部状态，所以此时说产生副作用也是合情合理的。


## Reactive

|			| One 		| Many									|
| :------	| ------: 	| :------: 								|
| Sync		| T 		| Enumerable[T] / AsyncEnumerable[T]	|
| Async 	| Future[T] | Observable[T]	/ AsyncObservable[T]	|

上表给出了我们编程中四种基本的Effects；


> One & Sync
其实这种情况就是我们最常见的一个方法或者一个函数，执行它的时候，当前执行被阻塞，直到该方法返回。
这也是我们所谓的`Imperative`, 也就是命令式。

> One & Async
这种情况也很常见，一般是一个异步的操作，该操作执行需要时间，会在稍后进行回调，此时当前执行不会被阻塞。
比如JS在语言层面就提供这种异步的支持。

> Many & Sync
这种情况其实和第一种情况很像，只是此时返回的值是一个集合。

> Many & Async
这种情况就类似比如我监听一个`Observable`,在某个时间点会收到值到来的通知。
这种情况也就是我们今天所说的`Reactive`, 所谓的响应式。

```
比较Many下：

Sync的Enumerable 是Pull类型的，也就是说我们想要获取某个值，需要主动的去通过`objectAtIndex`类似的方法去取。
Async的Observable是Push类型的，也就是说只要我监听了，只要有新的值过来我就会收到这个新的值。
```

所以响应式最大的特点是主动性。


## Observable

前面所说的响应式之所以叫响应式，主要就是Observable起的作用，也就是所谓的流。
我们可以把流想象成序列，类似Enumerable，不过比Enumerable更加动态，也就是此时的序列是异步的，而且类型会变化。

类型会变化怎么理解，因为是序列那么肯定是可以获取序列中的值的，所谓的变化指的就是获取序列值的时候会有变化。获取序列中的值，我们可以用最简单的getter来说明。


> normal
var obj: () => String

obj() // 序列正常发送，获取到某个字符串

> exception
var obj: () => String

obj() // 此时序列发送异常，所以也就不会获取到字符串

> termination
var obj: () => String

obj() // 此时序列终止，同样的也就不会获取到字符串

这三种情况大家看了应该很熟悉，因为Observable就是按这三种情况来设计的，Observable作为一个序列，在这个序列中可以发送event，因为有之前所说的变化，所以这个event对应的也就是这三种不同的状态。下面即是RxSwift中所定义的Event类型。

```
public enum Event<Element> {
    /// Next element is produced.
    case next(Element)

    /// Sequence terminated with an error.
    case error(Swift.Error)

    /// Sequence completed successfully.
    case completed
}
```

## Hot & Cold
