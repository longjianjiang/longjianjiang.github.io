---
layout: post
title:  "MMKV阅读笔记"
date:   2018-11-02
excerpt:  "本文是笔者阅读MMKV的笔记"
tag:
- iOS
comments: true
---

MMKV是一个key-value存储的库，下面笔者来分析下它的源代码。

# C函数

> MMKV中使用了一些C语言提供的内存和文件相关的函数，下面先列举出来：

## 文件相关函数

`int open(const char *, int, ...);`
将给定的文件路径以指定flags和指定mode打开，返回file descriptor。具体flags和mode的取值可以参看头文件注释。

`int ftruncate(int fd, off_t length);`
将open函数返回的file descriptor中指向的文件大小改为length指定的大小。如果原来文件大小大于length的话，则超过部分会被丢弃。

`int fstat(int, struct stat *buf);`
给定open函数返回的file descriptor，返回该文件描述符指向的文件的文件信息，将其存储在buf指针指向的结构体中。

`int stat(const char *file_name, struct stat *buf);`
给定文件名，返回该文件对应的文件信息，将其存储在buf指针指向的结构体中。

`int lstat(const char *file_name, struct stat *buf);`
和stat函数功能一样，只是当文件是符号链接时，lstat返回的是该符号链接的信息。

## 内存相关函数

`void *memcpy(void *__dst, const void *__src, size_t __n);`
将src地址开始的连续n个字节数据复制到以dst地址开始的空间内。

`void *memset(void *__b, int __c, size_t __len);`
将b地址开始的前len个字节全部设置为c。当b指向一段字符时，c也可以为char类型，实际设置的则是该字符对应的ASCII码值。

`void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize);`
将open函数返回的file descriptor中长为length的部分对应到以start地址（设置为nullptr系统会自动分配，然后返回）开始的内存区域中。实现操作内存映射到文件中，也就是对内存的读写也就是对文件的读写。offsize表示文件偏移量，一般设置位0表示从文件最开始部分开始映射。此时需要将flags设置为`MAP_SHARED`。

`int mlock(const void *addr, size_t len);`
将内存指定大小加锁

`int munlock(const void *addr, size_t len);`
将内存指定大小解锁

# Protocol Buffer

> MMKV使用PB来进行数据的序列化存储

PB是Google开源的一种通信协议，和XML的功能是类似的，PB使用`varint`来压缩数据，这样节约了存储空间，提高了传输速度。

## varint

- 使用最少的字节来保存一个数字，比如一个int32_t的value存1，原本需要4个字节，而实际这个数字只占用了一个字节，所以使用该种方式只需要占用一个字节就可以保存改数字了。

- 这种方式的每个字节的第一位有特殊含义，如果该位为1说明后续的字节是该数字的一部分；如果该位为0，说明此时的字节就是该数字的最后一个字节。

> 而且PB使用了小端的方式来存储，也就是第一个字节存储了数字的最低位。 大端则第一个字节存储了最高位。

举个例子，在PB的varint下，150二进制存储为`9601`，变换如下所示:

```
96 01 = 1001 0110  0000 0001
       → 000 0001  ++  001 0110 (去掉首位标志位，倒置字节顺序)
       → 10010110
       → 128 + 16 + 4 + 2 = 150
```

# 编码 & 解码

前面说到MMKV使用PB进行数据序列化，实际工程中使用上述两个类进行二进制编码和解码。

## MiniCodedOutputData

> 该类用于编码

```
uint8_t *m_ptr;
size_t m_size;
int32_t m_position;

MiniCodedOutputData::MiniCodedOutputData(void *ptr, size_t len)
    : m_ptr((uint8_t *) ptr), m_size(len), m_position(0) {
}

MiniCodedOutputData::MiniCodedOutputData(NSMutableData *oData)
    : m_ptr((uint8_t *) oData.mutableBytes), m_size(oData.length), m_position(0) {
}
```

上面是该类的属性和两个构造方法，用于初始化data指针和data长度和当前position。为接下来往data中写数据做好准备。

### write

write方法分为四类，varint，浮点型（float & double），string，data五种, 其中varint和浮点型内部都会调用`writeRawByte`来将一个字节的数据存进data中。

- byte

将一个字节的数据存储到data中很简单，首先判断位置有没有越界，然后一个简单的赋值操作：

```
void MiniCodedOutputData::writeRawByte(uint8_t value) {
	if (m_position == m_size) {
		NSString *reason = [NSString stringWithFormat:@"position: %d, bufferLength: %u", m_position, (unsigned int) m_size];
		@throw [NSException exceptionWithName:@"OutOfSpace" reason:reason userInfo:nil];
	}

	m_ptr[m_position++] = value;
}
```

- varint

write varint时分32位和64位，下面以32位为例来说明：

一个while循环：
1.首先判断这个value是不是不大于7位；
1.1 如果不大于7位，直接write一个字节，首字节为0，代表了这就是该value的最后一个字节；最后返回
1.2 如果大于7位，首页取value低位开始的七位，同时首位设置为1，代表该value后面还有字节；
1.2.1 将value右移7位，继续回到步骤1

```
void MiniCodedOutputData::writeRawVarint32(int32_t value) {
	while (YES) {
		if ((value & ~0x7f) == 0) {
			this->writeRawByte(value);
			return;
		} else {
			this->writeRawByte((value & 0x7f) | 0x80);
			value = logicalRightShift32(value, 7);
		}
	}
}
```

- 浮点型

write 浮点型没有使用varint，所以每个字节的8位都是用来存放数据的，下面以float来举例说明：

第一次取低位的8位，即一个字节的数据，write进data；
右移value8位，继续取低位的8位，即一个字节的数据，write进data；
右移value16位，继续取低位的8位，即一个字节的数据，write进data；
右移value24位，继续取低位的8位，即一个字节的数据，write进data；
此时32位数据已经全部write进data。

```
void MiniCodedOutputData::writeRawLittleEndian32(int32_t value) {
	this->writeRawByte((value) &0xff);
	this->writeRawByte((value >> 8) & 0xff);
	this->writeRawByte((value >> 16) & 0xff);
	this->writeRawByte((value >> 24) & 0xff);
}
```

- string

write string 相比之前的两种少了位运算和移位操作，不过多了一个存储string length的操作，然后调用NSString的`getBytes:maxLength:usedLength:encoding:options:range:remainingRange:`方法将string中的bytes数据存入我们给定的data的位置中。

```
void MiniCodedOutputData::writeString(NSString *value) {
	NSUInteger numberOfBytes = [value lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
	this->writeRawVarint32((int32_t) numberOfBytes);
	[value getBytes:m_ptr + m_position
	         maxLength:numberOfBytes
	        usedLength:0
	          encoding:NSUTF8StringEncoding
	           options:0
	             range:NSMakeRange(0, value.length)
	    remainingRange:nullptr];
	m_position += numberOfBytes;
}
```

- data

write data 调用C函数`memcpy`将data中的bytes数据拷贝到我们MiniCodedOutputData中的data中。

```
void MiniCodedOutputData::writeRawData(NSData *value, int32_t offset, int32_t length) {
	if (length <= 0) {
		return;
	}
	if (m_size - m_position >= length) {
		memcpy(m_ptr + m_position, ((uint8_t *) value.bytes) + offset, length);
		m_position += length;
	} else {
		[NSException exceptionWithName:@"Space" reason:@"too much data than calc" userInfo:nil];
	}
}
```

## MiniCodedInputData

> 该类用于解码，

# 接口

MMKV提供了一系列的set&get的方法，类似`NSUserDefaults`。

```
MMKV *mmkv = [MMKV defaultMMKV];
    
[mmkv setBool:YES forKey:@"bool"];
BOOL bValue = [mmkv getBoolForKey:@"bool"];
    
[mmkv setInt32:-1024 forKey:@"int32"];
int32_t iValue = [mmkv getInt32ForKey:@"int32"];
    
[mmkv setObject:@"hello, mmkv" forKey:@"string"];
NSString *str = [mmkv getObjectOfClass:NSString.class forKey:@"string"];
```

以上代码从MMKV Demo中摘录，我们可以发现使用起来和`NSUserDefaults`十分类似。

## set
MMKV提供给我们的各种类型的set方法，其实内部都是通过将不同类型的数据先转成二进制形式，然后内部再调用`setData:forKey:`完成存储。

# References

[https://developers.google.com/protocol-buffers/docs/encoding](https://developers.google.com/protocol-buffers/docs/encoding)
[https://github.com/Tencent/MMKV](https://github.com/Tencent/MMKV)
